// This file is generated by rust-protobuf 2.8.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `proto/configuration/blobstore/blobstore.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_2;

#[derive(PartialEq,Clone,Default)]
pub struct BlobstoreConfiguration {
    // message fields
    pub content_addressable_storage: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub action_cache: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlobstoreConfiguration {
    fn default() -> &'a BlobstoreConfiguration {
        <BlobstoreConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl BlobstoreConfiguration {
    pub fn new() -> BlobstoreConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration content_addressable_storage = 1;


    pub fn get_content_addressable_storage(&self) -> &BlobAccessConfiguration {
        self.content_addressable_storage.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_content_addressable_storage(&mut self) {
        self.content_addressable_storage.clear();
    }

    pub fn has_content_addressable_storage(&self) -> bool {
        self.content_addressable_storage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_addressable_storage(&mut self, v: BlobAccessConfiguration) {
        self.content_addressable_storage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_addressable_storage(&mut self) -> &mut BlobAccessConfiguration {
        if self.content_addressable_storage.is_none() {
            self.content_addressable_storage.set_default();
        }
        self.content_addressable_storage.as_mut().unwrap()
    }

    // Take field
    pub fn take_content_addressable_storage(&mut self) -> BlobAccessConfiguration {
        self.content_addressable_storage.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .blobstore.BlobAccessConfiguration action_cache = 2;


    pub fn get_action_cache(&self) -> &BlobAccessConfiguration {
        self.action_cache.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_action_cache(&mut self) {
        self.action_cache.clear();
    }

    pub fn has_action_cache(&self) -> bool {
        self.action_cache.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_cache(&mut self, v: BlobAccessConfiguration) {
        self.action_cache = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_cache(&mut self) -> &mut BlobAccessConfiguration {
        if self.action_cache.is_none() {
            self.action_cache.set_default();
        }
        self.action_cache.as_mut().unwrap()
    }

    // Take field
    pub fn take_action_cache(&mut self) -> BlobAccessConfiguration {
        self.action_cache.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }
}

impl ::protobuf::Message for BlobstoreConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.content_addressable_storage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action_cache {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content_addressable_storage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action_cache)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.content_addressable_storage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.action_cache.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.content_addressable_storage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.action_cache.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlobstoreConfiguration {
        BlobstoreConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "content_addressable_storage",
                    |m: &BlobstoreConfiguration| { &m.content_addressable_storage },
                    |m: &mut BlobstoreConfiguration| { &mut m.content_addressable_storage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "action_cache",
                    |m: &BlobstoreConfiguration| { &m.action_cache },
                    |m: &mut BlobstoreConfiguration| { &mut m.action_cache },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlobstoreConfiguration>(
                    "BlobstoreConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlobstoreConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<BlobstoreConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlobstoreConfiguration,
        };
        unsafe {
            instance.get(BlobstoreConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for BlobstoreConfiguration {
    fn clear(&mut self) {
        self.content_addressable_storage.clear();
        self.action_cache.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlobstoreConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlobstoreConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlobAccessConfiguration {
    // message oneof groups
    pub backend: ::std::option::Option<BlobAccessConfiguration_oneof_backend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlobAccessConfiguration {
    fn default() -> &'a BlobAccessConfiguration {
        <BlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum BlobAccessConfiguration_oneof_backend {
    redis(RedisBlobAccessConfiguration),
    http(HTTPBlobAccessConfiguration),
    read_caching(ReadCachingBlobAccessConfiguration),
    size_distinguishing(SizeDistinguishingBlobAccessConfiguration),
    grpc(super::grpc::ClientConfiguration),
    error(super::status::Status),
    sharding(ShardingBlobAccessConfiguration),
    mirrored(MirroredBlobAccessConfiguration),
    local(LocalBlobAccessConfiguration),
    existence_caching(ExistenceCachingBlobAccessConfiguration),
    completeness_checking(::std::boxed::Box<BlobAccessConfiguration>),
    read_fallback(ReadFallbackBlobAccessConfiguration),
    reference_expanding(ReferenceExpandingBlobAccessConfiguration),
    demultiplexing(DemultiplexingBlobAccessConfiguration),
    hierarchical_instance_names(::std::boxed::Box<BlobAccessConfiguration>),
    action_result_expiring(ActionResultExpiringBlobAccessConfiguration),
    read_canarying(ReadCanaryingBlobAccessConfiguration),
}

impl BlobAccessConfiguration {
    pub fn new() -> BlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.RedisBlobAccessConfiguration redis = 2;


    pub fn get_redis(&self) -> &RedisBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::redis(ref v)) => v,
            _ => RedisBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_redis(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_redis(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::redis(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_redis(&mut self, v: RedisBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::redis(v))
    }

    // Mutable pointer to the field.
    pub fn mut_redis(&mut self) -> &mut RedisBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::redis(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::redis(RedisBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::redis(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_redis(&mut self) -> RedisBlobAccessConfiguration {
        if self.has_redis() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::redis(v)) => v,
                _ => panic!(),
            }
        } else {
            RedisBlobAccessConfiguration::new()
        }
    }

    // .blobstore.HTTPBlobAccessConfiguration http = 3;


    pub fn get_http(&self) -> &HTTPBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::http(ref v)) => v,
            _ => HTTPBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_http(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_http(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::http(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: HTTPBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::http(v))
    }

    // Mutable pointer to the field.
    pub fn mut_http(&mut self) -> &mut HTTPBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::http(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::http(HTTPBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::http(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_http(&mut self) -> HTTPBlobAccessConfiguration {
        if self.has_http() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::http(v)) => v,
                _ => panic!(),
            }
        } else {
            HTTPBlobAccessConfiguration::new()
        }
    }

    // .blobstore.ReadCachingBlobAccessConfiguration read_caching = 4;


    pub fn get_read_caching(&self) -> &ReadCachingBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_caching(ref v)) => v,
            _ => ReadCachingBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_read_caching(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_read_caching(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_caching(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_caching(&mut self, v: ReadCachingBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_caching(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_caching(&mut self) -> &mut ReadCachingBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_caching(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_caching(ReadCachingBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_caching(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_caching(&mut self) -> ReadCachingBlobAccessConfiguration {
        if self.has_read_caching() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_caching(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadCachingBlobAccessConfiguration::new()
        }
    }

    // .blobstore.SizeDistinguishingBlobAccessConfiguration size_distinguishing = 5;


    pub fn get_size_distinguishing(&self) -> &SizeDistinguishingBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::size_distinguishing(ref v)) => v,
            _ => SizeDistinguishingBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_size_distinguishing(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_size_distinguishing(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::size_distinguishing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_size_distinguishing(&mut self, v: SizeDistinguishingBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::size_distinguishing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_size_distinguishing(&mut self) -> &mut SizeDistinguishingBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::size_distinguishing(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::size_distinguishing(SizeDistinguishingBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::size_distinguishing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_size_distinguishing(&mut self) -> SizeDistinguishingBlobAccessConfiguration {
        if self.has_size_distinguishing() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::size_distinguishing(v)) => v,
                _ => panic!(),
            }
        } else {
            SizeDistinguishingBlobAccessConfiguration::new()
        }
    }

    // .grpc.ClientConfiguration grpc = 7;


    pub fn get_grpc(&self) -> &super::grpc::ClientConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::grpc(ref v)) => v,
            _ => super::grpc::ClientConfiguration::default_instance(),
        }
    }
    pub fn clear_grpc(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_grpc(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::grpc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_grpc(&mut self, v: super::grpc::ClientConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::grpc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_grpc(&mut self) -> &mut super::grpc::ClientConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::grpc(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::grpc(super::grpc::ClientConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::grpc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_grpc(&mut self) -> super::grpc::ClientConfiguration {
        if self.has_grpc() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::grpc(v)) => v,
                _ => panic!(),
            }
        } else {
            super::grpc::ClientConfiguration::new()
        }
    }

    // .google.rpc.Status error = 8;


    pub fn get_error(&self) -> &super::status::Status {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::error(ref v)) => v,
            _ => super::status::Status::default_instance(),
        }
    }
    pub fn clear_error(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::status::Status) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut super::status::Status {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::error(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::error(super::status::Status::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> super::status::Status {
        if self.has_error() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::error(v)) => v,
                _ => panic!(),
            }
        } else {
            super::status::Status::new()
        }
    }

    // .blobstore.ShardingBlobAccessConfiguration sharding = 9;


    pub fn get_sharding(&self) -> &ShardingBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::sharding(ref v)) => v,
            _ => ShardingBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_sharding(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_sharding(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::sharding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sharding(&mut self, v: ShardingBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::sharding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sharding(&mut self) -> &mut ShardingBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::sharding(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::sharding(ShardingBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::sharding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sharding(&mut self) -> ShardingBlobAccessConfiguration {
        if self.has_sharding() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::sharding(v)) => v,
                _ => panic!(),
            }
        } else {
            ShardingBlobAccessConfiguration::new()
        }
    }

    // .blobstore.MirroredBlobAccessConfiguration mirrored = 14;


    pub fn get_mirrored(&self) -> &MirroredBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::mirrored(ref v)) => v,
            _ => MirroredBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_mirrored(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_mirrored(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::mirrored(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mirrored(&mut self, v: MirroredBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::mirrored(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mirrored(&mut self) -> &mut MirroredBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::mirrored(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::mirrored(MirroredBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::mirrored(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mirrored(&mut self) -> MirroredBlobAccessConfiguration {
        if self.has_mirrored() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::mirrored(v)) => v,
                _ => panic!(),
            }
        } else {
            MirroredBlobAccessConfiguration::new()
        }
    }

    // .blobstore.LocalBlobAccessConfiguration local = 15;


    pub fn get_local(&self) -> &LocalBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::local(ref v)) => v,
            _ => LocalBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_local(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_local(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::local(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: LocalBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::local(v))
    }

    // Mutable pointer to the field.
    pub fn mut_local(&mut self) -> &mut LocalBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::local(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::local(LocalBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::local(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_local(&mut self) -> LocalBlobAccessConfiguration {
        if self.has_local() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::local(v)) => v,
                _ => panic!(),
            }
        } else {
            LocalBlobAccessConfiguration::new()
        }
    }

    // .blobstore.ExistenceCachingBlobAccessConfiguration existence_caching = 16;


    pub fn get_existence_caching(&self) -> &ExistenceCachingBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::existence_caching(ref v)) => v,
            _ => ExistenceCachingBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_existence_caching(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_existence_caching(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::existence_caching(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_existence_caching(&mut self, v: ExistenceCachingBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::existence_caching(v))
    }

    // Mutable pointer to the field.
    pub fn mut_existence_caching(&mut self) -> &mut ExistenceCachingBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::existence_caching(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::existence_caching(ExistenceCachingBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::existence_caching(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_existence_caching(&mut self) -> ExistenceCachingBlobAccessConfiguration {
        if self.has_existence_caching() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::existence_caching(v)) => v,
                _ => panic!(),
            }
        } else {
            ExistenceCachingBlobAccessConfiguration::new()
        }
    }

    // .blobstore.BlobAccessConfiguration completeness_checking = 17;


    pub fn get_completeness_checking(&self) -> &BlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::completeness_checking(ref v)) => v,
            _ => BlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_completeness_checking(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_completeness_checking(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::completeness_checking(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_completeness_checking(&mut self, v: BlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::completeness_checking(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_completeness_checking(&mut self) -> &mut BlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::completeness_checking(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::completeness_checking(::std::boxed::Box::new(BlobAccessConfiguration::new())));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::completeness_checking(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_completeness_checking(&mut self) -> BlobAccessConfiguration {
        if self.has_completeness_checking() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::completeness_checking(v)) => *v,
                _ => panic!(),
            }
        } else {
            BlobAccessConfiguration::new()
        }
    }

    // .blobstore.ReadFallbackBlobAccessConfiguration read_fallback = 18;


    pub fn get_read_fallback(&self) -> &ReadFallbackBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_fallback(ref v)) => v,
            _ => ReadFallbackBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_read_fallback(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_read_fallback(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_fallback(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_fallback(&mut self, v: ReadFallbackBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_fallback(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_fallback(&mut self) -> &mut ReadFallbackBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_fallback(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_fallback(ReadFallbackBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_fallback(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_fallback(&mut self) -> ReadFallbackBlobAccessConfiguration {
        if self.has_read_fallback() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_fallback(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadFallbackBlobAccessConfiguration::new()
        }
    }

    // .blobstore.ReferenceExpandingBlobAccessConfiguration reference_expanding = 19;


    pub fn get_reference_expanding(&self) -> &ReferenceExpandingBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::reference_expanding(ref v)) => v,
            _ => ReferenceExpandingBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_reference_expanding(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_reference_expanding(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::reference_expanding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reference_expanding(&mut self, v: ReferenceExpandingBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::reference_expanding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reference_expanding(&mut self) -> &mut ReferenceExpandingBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::reference_expanding(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::reference_expanding(ReferenceExpandingBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::reference_expanding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reference_expanding(&mut self) -> ReferenceExpandingBlobAccessConfiguration {
        if self.has_reference_expanding() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::reference_expanding(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceExpandingBlobAccessConfiguration::new()
        }
    }

    // .blobstore.DemultiplexingBlobAccessConfiguration demultiplexing = 20;


    pub fn get_demultiplexing(&self) -> &DemultiplexingBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::demultiplexing(ref v)) => v,
            _ => DemultiplexingBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_demultiplexing(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_demultiplexing(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::demultiplexing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_demultiplexing(&mut self, v: DemultiplexingBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::demultiplexing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_demultiplexing(&mut self) -> &mut DemultiplexingBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::demultiplexing(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::demultiplexing(DemultiplexingBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::demultiplexing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_demultiplexing(&mut self) -> DemultiplexingBlobAccessConfiguration {
        if self.has_demultiplexing() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::demultiplexing(v)) => v,
                _ => panic!(),
            }
        } else {
            DemultiplexingBlobAccessConfiguration::new()
        }
    }

    // .blobstore.BlobAccessConfiguration hierarchical_instance_names = 21;


    pub fn get_hierarchical_instance_names(&self) -> &BlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(ref v)) => v,
            _ => BlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_hierarchical_instance_names(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_hierarchical_instance_names(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hierarchical_instance_names(&mut self, v: BlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_hierarchical_instance_names(&mut self) -> &mut BlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(::std::boxed::Box::new(BlobAccessConfiguration::new())));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hierarchical_instance_names(&mut self) -> BlobAccessConfiguration {
        if self.has_hierarchical_instance_names() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(v)) => *v,
                _ => panic!(),
            }
        } else {
            BlobAccessConfiguration::new()
        }
    }

    // .blobstore.ActionResultExpiringBlobAccessConfiguration action_result_expiring = 22;


    pub fn get_action_result_expiring(&self) -> &ActionResultExpiringBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::action_result_expiring(ref v)) => v,
            _ => ActionResultExpiringBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_action_result_expiring(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_action_result_expiring(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::action_result_expiring(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_result_expiring(&mut self, v: ActionResultExpiringBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::action_result_expiring(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_result_expiring(&mut self) -> &mut ActionResultExpiringBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::action_result_expiring(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::action_result_expiring(ActionResultExpiringBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::action_result_expiring(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_result_expiring(&mut self) -> ActionResultExpiringBlobAccessConfiguration {
        if self.has_action_result_expiring() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::action_result_expiring(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionResultExpiringBlobAccessConfiguration::new()
        }
    }

    // .blobstore.ReadCanaryingBlobAccessConfiguration read_canarying = 23;


    pub fn get_read_canarying(&self) -> &ReadCanaryingBlobAccessConfiguration {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_canarying(ref v)) => v,
            _ => ReadCanaryingBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_read_canarying(&mut self) {
        self.backend = ::std::option::Option::None;
    }

    pub fn has_read_canarying(&self) -> bool {
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_canarying(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_canarying(&mut self, v: ReadCanaryingBlobAccessConfiguration) {
        self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_canarying(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_canarying(&mut self) -> &mut ReadCanaryingBlobAccessConfiguration {
        if let ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_canarying(_)) = self.backend {
        } else {
            self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_canarying(ReadCanaryingBlobAccessConfiguration::new()));
        }
        match self.backend {
            ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_canarying(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_canarying(&mut self) -> ReadCanaryingBlobAccessConfiguration {
        if self.has_read_canarying() {
            match self.backend.take() {
                ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_canarying(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadCanaryingBlobAccessConfiguration::new()
        }
    }
}

impl ::protobuf::Message for BlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        if let Some(BlobAccessConfiguration_oneof_backend::redis(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::http(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::read_caching(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::size_distinguishing(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::grpc(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::error(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::sharding(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::mirrored(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::local(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::existence_caching(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::completeness_checking(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::read_fallback(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::reference_expanding(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::demultiplexing(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::action_result_expiring(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobAccessConfiguration_oneof_backend::read_canarying(ref v)) = self.backend {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::redis(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::http(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_caching(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::size_distinguishing(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::grpc(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::error(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::sharding(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::mirrored(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::local(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::existence_caching(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::completeness_checking(::std::boxed::Box::new(is.read_message()?)));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_fallback(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::reference_expanding(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::demultiplexing(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(::std::boxed::Box::new(is.read_message()?)));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::action_result_expiring(is.read_message()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backend = ::std::option::Option::Some(BlobAccessConfiguration_oneof_backend::read_canarying(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.backend {
            match v {
                &BlobAccessConfiguration_oneof_backend::redis(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::http(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::read_caching(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::size_distinguishing(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::grpc(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::sharding(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::mirrored(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::local(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::existence_caching(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::completeness_checking(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::read_fallback(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::reference_expanding(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::demultiplexing(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::action_result_expiring(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobAccessConfiguration_oneof_backend::read_canarying(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.backend {
            match v {
                &BlobAccessConfiguration_oneof_backend::redis(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::http(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::read_caching(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::size_distinguishing(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::grpc(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::error(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::sharding(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::mirrored(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::local(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::existence_caching(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::completeness_checking(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::read_fallback(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::reference_expanding(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::demultiplexing(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::hierarchical_instance_names(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::action_result_expiring(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobAccessConfiguration_oneof_backend::read_canarying(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlobAccessConfiguration {
        BlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RedisBlobAccessConfiguration>(
                    "redis",
                    BlobAccessConfiguration::has_redis,
                    BlobAccessConfiguration::get_redis,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HTTPBlobAccessConfiguration>(
                    "http",
                    BlobAccessConfiguration::has_http,
                    BlobAccessConfiguration::get_http,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReadCachingBlobAccessConfiguration>(
                    "read_caching",
                    BlobAccessConfiguration::has_read_caching,
                    BlobAccessConfiguration::get_read_caching,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SizeDistinguishingBlobAccessConfiguration>(
                    "size_distinguishing",
                    BlobAccessConfiguration::has_size_distinguishing,
                    BlobAccessConfiguration::get_size_distinguishing,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::grpc::ClientConfiguration>(
                    "grpc",
                    BlobAccessConfiguration::has_grpc,
                    BlobAccessConfiguration::get_grpc,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::status::Status>(
                    "error",
                    BlobAccessConfiguration::has_error,
                    BlobAccessConfiguration::get_error,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ShardingBlobAccessConfiguration>(
                    "sharding",
                    BlobAccessConfiguration::has_sharding,
                    BlobAccessConfiguration::get_sharding,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MirroredBlobAccessConfiguration>(
                    "mirrored",
                    BlobAccessConfiguration::has_mirrored,
                    BlobAccessConfiguration::get_mirrored,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LocalBlobAccessConfiguration>(
                    "local",
                    BlobAccessConfiguration::has_local,
                    BlobAccessConfiguration::get_local,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExistenceCachingBlobAccessConfiguration>(
                    "existence_caching",
                    BlobAccessConfiguration::has_existence_caching,
                    BlobAccessConfiguration::get_existence_caching,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BlobAccessConfiguration>(
                    "completeness_checking",
                    BlobAccessConfiguration::has_completeness_checking,
                    BlobAccessConfiguration::get_completeness_checking,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReadFallbackBlobAccessConfiguration>(
                    "read_fallback",
                    BlobAccessConfiguration::has_read_fallback,
                    BlobAccessConfiguration::get_read_fallback,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceExpandingBlobAccessConfiguration>(
                    "reference_expanding",
                    BlobAccessConfiguration::has_reference_expanding,
                    BlobAccessConfiguration::get_reference_expanding,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DemultiplexingBlobAccessConfiguration>(
                    "demultiplexing",
                    BlobAccessConfiguration::has_demultiplexing,
                    BlobAccessConfiguration::get_demultiplexing,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BlobAccessConfiguration>(
                    "hierarchical_instance_names",
                    BlobAccessConfiguration::has_hierarchical_instance_names,
                    BlobAccessConfiguration::get_hierarchical_instance_names,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionResultExpiringBlobAccessConfiguration>(
                    "action_result_expiring",
                    BlobAccessConfiguration::has_action_result_expiring,
                    BlobAccessConfiguration::get_action_result_expiring,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReadCanaryingBlobAccessConfiguration>(
                    "read_canarying",
                    BlobAccessConfiguration::has_read_canarying,
                    BlobAccessConfiguration::get_read_canarying,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlobAccessConfiguration>(
                    "BlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<BlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlobAccessConfiguration,
        };
        unsafe {
            instance.get(BlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for BlobAccessConfiguration {
    fn clear(&mut self) {
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadCachingBlobAccessConfiguration {
    // message fields
    pub slow: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub fast: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub replicator: ::protobuf::SingularPtrField<BlobReplicatorConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadCachingBlobAccessConfiguration {
    fn default() -> &'a ReadCachingBlobAccessConfiguration {
        <ReadCachingBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ReadCachingBlobAccessConfiguration {
    pub fn new() -> ReadCachingBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration slow = 1;


    pub fn get_slow(&self) -> &BlobAccessConfiguration {
        self.slow.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_slow(&mut self) {
        self.slow.clear();
    }

    pub fn has_slow(&self) -> bool {
        self.slow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slow(&mut self, v: BlobAccessConfiguration) {
        self.slow = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slow(&mut self) -> &mut BlobAccessConfiguration {
        if self.slow.is_none() {
            self.slow.set_default();
        }
        self.slow.as_mut().unwrap()
    }

    // Take field
    pub fn take_slow(&mut self) -> BlobAccessConfiguration {
        self.slow.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .blobstore.BlobAccessConfiguration fast = 2;


    pub fn get_fast(&self) -> &BlobAccessConfiguration {
        self.fast.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_fast(&mut self) {
        self.fast.clear();
    }

    pub fn has_fast(&self) -> bool {
        self.fast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fast(&mut self, v: BlobAccessConfiguration) {
        self.fast = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fast(&mut self) -> &mut BlobAccessConfiguration {
        if self.fast.is_none() {
            self.fast.set_default();
        }
        self.fast.as_mut().unwrap()
    }

    // Take field
    pub fn take_fast(&mut self) -> BlobAccessConfiguration {
        self.fast.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .blobstore.BlobReplicatorConfiguration replicator = 3;


    pub fn get_replicator(&self) -> &BlobReplicatorConfiguration {
        self.replicator.as_ref().unwrap_or_else(|| BlobReplicatorConfiguration::default_instance())
    }
    pub fn clear_replicator(&mut self) {
        self.replicator.clear();
    }

    pub fn has_replicator(&self) -> bool {
        self.replicator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicator(&mut self, v: BlobReplicatorConfiguration) {
        self.replicator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replicator(&mut self) -> &mut BlobReplicatorConfiguration {
        if self.replicator.is_none() {
            self.replicator.set_default();
        }
        self.replicator.as_mut().unwrap()
    }

    // Take field
    pub fn take_replicator(&mut self) -> BlobReplicatorConfiguration {
        self.replicator.take().unwrap_or_else(|| BlobReplicatorConfiguration::new())
    }
}

impl ::protobuf::Message for ReadCachingBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.slow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fast {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.replicator {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.slow)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fast)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.replicator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.slow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.replicator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.slow.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fast.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.replicator.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadCachingBlobAccessConfiguration {
        ReadCachingBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "slow",
                    |m: &ReadCachingBlobAccessConfiguration| { &m.slow },
                    |m: &mut ReadCachingBlobAccessConfiguration| { &mut m.slow },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "fast",
                    |m: &ReadCachingBlobAccessConfiguration| { &m.fast },
                    |m: &mut ReadCachingBlobAccessConfiguration| { &mut m.fast },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobReplicatorConfiguration>>(
                    "replicator",
                    |m: &ReadCachingBlobAccessConfiguration| { &m.replicator },
                    |m: &mut ReadCachingBlobAccessConfiguration| { &mut m.replicator },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadCachingBlobAccessConfiguration>(
                    "ReadCachingBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadCachingBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<ReadCachingBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadCachingBlobAccessConfiguration,
        };
        unsafe {
            instance.get(ReadCachingBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for ReadCachingBlobAccessConfiguration {
    fn clear(&mut self) {
        self.slow.clear();
        self.fast.clear();
        self.replicator.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadCachingBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadCachingBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClusteredRedisBlobAccessConfiguration {
    // message fields
    pub endpoints: ::protobuf::RepeatedField<::std::string::String>,
    pub maximum_retries: u32,
    pub minimum_retry_backoff: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub maximum_retry_backoff: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClusteredRedisBlobAccessConfiguration {
    fn default() -> &'a ClusteredRedisBlobAccessConfiguration {
        <ClusteredRedisBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ClusteredRedisBlobAccessConfiguration {
    pub fn new() -> ClusteredRedisBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // repeated string endpoints = 1;


    pub fn get_endpoints(&self) -> &[::std::string::String] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }

    // uint32 maximum_retries = 2;


    pub fn get_maximum_retries(&self) -> u32 {
        self.maximum_retries
    }
    pub fn clear_maximum_retries(&mut self) {
        self.maximum_retries = 0;
    }

    // Param is passed by value, moved
    pub fn set_maximum_retries(&mut self, v: u32) {
        self.maximum_retries = v;
    }

    // .google.protobuf.Duration minimum_retry_backoff = 3;


    pub fn get_minimum_retry_backoff(&self) -> &::protobuf::well_known_types::Duration {
        self.minimum_retry_backoff.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_minimum_retry_backoff(&mut self) {
        self.minimum_retry_backoff.clear();
    }

    pub fn has_minimum_retry_backoff(&self) -> bool {
        self.minimum_retry_backoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum_retry_backoff(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.minimum_retry_backoff = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimum_retry_backoff(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.minimum_retry_backoff.is_none() {
            self.minimum_retry_backoff.set_default();
        }
        self.minimum_retry_backoff.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimum_retry_backoff(&mut self) -> ::protobuf::well_known_types::Duration {
        self.minimum_retry_backoff.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration maximum_retry_backoff = 4;


    pub fn get_maximum_retry_backoff(&self) -> &::protobuf::well_known_types::Duration {
        self.maximum_retry_backoff.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_maximum_retry_backoff(&mut self) {
        self.maximum_retry_backoff.clear();
    }

    pub fn has_maximum_retry_backoff(&self) -> bool {
        self.maximum_retry_backoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_retry_backoff(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.maximum_retry_backoff = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maximum_retry_backoff(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.maximum_retry_backoff.is_none() {
            self.maximum_retry_backoff.set_default();
        }
        self.maximum_retry_backoff.as_mut().unwrap()
    }

    // Take field
    pub fn take_maximum_retry_backoff(&mut self) -> ::protobuf::well_known_types::Duration {
        self.maximum_retry_backoff.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for ClusteredRedisBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.minimum_retry_backoff {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.maximum_retry_backoff {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.endpoints)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximum_retries = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.minimum_retry_backoff)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.maximum_retry_backoff)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.maximum_retries != 0 {
            my_size += ::protobuf::rt::value_size(2, self.maximum_retries, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.minimum_retry_backoff.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.maximum_retry_backoff.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.endpoints {
            os.write_string(1, &v)?;
        };
        if self.maximum_retries != 0 {
            os.write_uint32(2, self.maximum_retries)?;
        }
        if let Some(ref v) = self.minimum_retry_backoff.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.maximum_retry_backoff.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClusteredRedisBlobAccessConfiguration {
        ClusteredRedisBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoints",
                    |m: &ClusteredRedisBlobAccessConfiguration| { &m.endpoints },
                    |m: &mut ClusteredRedisBlobAccessConfiguration| { &mut m.endpoints },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maximum_retries",
                    |m: &ClusteredRedisBlobAccessConfiguration| { &m.maximum_retries },
                    |m: &mut ClusteredRedisBlobAccessConfiguration| { &mut m.maximum_retries },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "minimum_retry_backoff",
                    |m: &ClusteredRedisBlobAccessConfiguration| { &m.minimum_retry_backoff },
                    |m: &mut ClusteredRedisBlobAccessConfiguration| { &mut m.minimum_retry_backoff },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "maximum_retry_backoff",
                    |m: &ClusteredRedisBlobAccessConfiguration| { &m.maximum_retry_backoff },
                    |m: &mut ClusteredRedisBlobAccessConfiguration| { &mut m.maximum_retry_backoff },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClusteredRedisBlobAccessConfiguration>(
                    "ClusteredRedisBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClusteredRedisBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<ClusteredRedisBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClusteredRedisBlobAccessConfiguration,
        };
        unsafe {
            instance.get(ClusteredRedisBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for ClusteredRedisBlobAccessConfiguration {
    fn clear(&mut self) {
        self.endpoints.clear();
        self.maximum_retries = 0;
        self.minimum_retry_backoff.clear();
        self.maximum_retry_backoff.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClusteredRedisBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusteredRedisBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleRedisBlobAccessConfiguration {
    // message fields
    pub endpoint: ::std::string::String,
    pub db: i32,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleRedisBlobAccessConfiguration {
    fn default() -> &'a SingleRedisBlobAccessConfiguration {
        <SingleRedisBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl SingleRedisBlobAccessConfiguration {
    pub fn new() -> SingleRedisBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // string endpoint = 1;


    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    // int32 db = 2;


    pub fn get_db(&self) -> i32 {
        self.db
    }
    pub fn clear_db(&mut self) {
        self.db = 0;
    }

    // Param is passed by value, moved
    pub fn set_db(&mut self, v: i32) {
        self.db = v;
    }

    // string password = 3;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SingleRedisBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.db = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.endpoint);
        }
        if self.db != 0 {
            my_size += ::protobuf::rt::value_size(2, self.db, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.endpoint.is_empty() {
            os.write_string(1, &self.endpoint)?;
        }
        if self.db != 0 {
            os.write_int32(2, self.db)?;
        }
        if !self.password.is_empty() {
            os.write_string(3, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleRedisBlobAccessConfiguration {
        SingleRedisBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoint",
                    |m: &SingleRedisBlobAccessConfiguration| { &m.endpoint },
                    |m: &mut SingleRedisBlobAccessConfiguration| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "db",
                    |m: &SingleRedisBlobAccessConfiguration| { &m.db },
                    |m: &mut SingleRedisBlobAccessConfiguration| { &mut m.db },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &SingleRedisBlobAccessConfiguration| { &m.password },
                    |m: &mut SingleRedisBlobAccessConfiguration| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SingleRedisBlobAccessConfiguration>(
                    "SingleRedisBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SingleRedisBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<SingleRedisBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SingleRedisBlobAccessConfiguration,
        };
        unsafe {
            instance.get(SingleRedisBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for SingleRedisBlobAccessConfiguration {
    fn clear(&mut self) {
        self.endpoint.clear();
        self.db = 0;
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleRedisBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleRedisBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedisBlobAccessConfiguration {
    // message fields
    pub tls: ::protobuf::SingularPtrField<super::tls::ClientConfiguration>,
    pub replication_count: i64,
    pub replication_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub dial_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub read_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub write_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // message oneof groups
    pub mode: ::std::option::Option<RedisBlobAccessConfiguration_oneof_mode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedisBlobAccessConfiguration {
    fn default() -> &'a RedisBlobAccessConfiguration {
        <RedisBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RedisBlobAccessConfiguration_oneof_mode {
    clustered(ClusteredRedisBlobAccessConfiguration),
    single(SingleRedisBlobAccessConfiguration),
}

impl RedisBlobAccessConfiguration {
    pub fn new() -> RedisBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.ClusteredRedisBlobAccessConfiguration clustered = 1;


    pub fn get_clustered(&self) -> &ClusteredRedisBlobAccessConfiguration {
        match self.mode {
            ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::clustered(ref v)) => v,
            _ => ClusteredRedisBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_clustered(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_clustered(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::clustered(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clustered(&mut self, v: ClusteredRedisBlobAccessConfiguration) {
        self.mode = ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::clustered(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clustered(&mut self) -> &mut ClusteredRedisBlobAccessConfiguration {
        if let ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::clustered(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::clustered(ClusteredRedisBlobAccessConfiguration::new()));
        }
        match self.mode {
            ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::clustered(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clustered(&mut self) -> ClusteredRedisBlobAccessConfiguration {
        if self.has_clustered() {
            match self.mode.take() {
                ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::clustered(v)) => v,
                _ => panic!(),
            }
        } else {
            ClusteredRedisBlobAccessConfiguration::new()
        }
    }

    // .blobstore.SingleRedisBlobAccessConfiguration single = 2;


    pub fn get_single(&self) -> &SingleRedisBlobAccessConfiguration {
        match self.mode {
            ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::single(ref v)) => v,
            _ => SingleRedisBlobAccessConfiguration::default_instance(),
        }
    }
    pub fn clear_single(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_single(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::single(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single(&mut self, v: SingleRedisBlobAccessConfiguration) {
        self.mode = ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::single(v))
    }

    // Mutable pointer to the field.
    pub fn mut_single(&mut self) -> &mut SingleRedisBlobAccessConfiguration {
        if let ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::single(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::single(SingleRedisBlobAccessConfiguration::new()));
        }
        match self.mode {
            ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::single(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_single(&mut self) -> SingleRedisBlobAccessConfiguration {
        if self.has_single() {
            match self.mode.take() {
                ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::single(v)) => v,
                _ => panic!(),
            }
        } else {
            SingleRedisBlobAccessConfiguration::new()
        }
    }

    // .tls.ClientConfiguration tls = 4;


    pub fn get_tls(&self) -> &super::tls::ClientConfiguration {
        self.tls.as_ref().unwrap_or_else(|| super::tls::ClientConfiguration::default_instance())
    }
    pub fn clear_tls(&mut self) {
        self.tls.clear();
    }

    pub fn has_tls(&self) -> bool {
        self.tls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls(&mut self, v: super::tls::ClientConfiguration) {
        self.tls = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tls(&mut self) -> &mut super::tls::ClientConfiguration {
        if self.tls.is_none() {
            self.tls.set_default();
        }
        self.tls.as_mut().unwrap()
    }

    // Take field
    pub fn take_tls(&mut self) -> super::tls::ClientConfiguration {
        self.tls.take().unwrap_or_else(|| super::tls::ClientConfiguration::new())
    }

    // int64 replication_count = 8;


    pub fn get_replication_count(&self) -> i64 {
        self.replication_count
    }
    pub fn clear_replication_count(&mut self) {
        self.replication_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_replication_count(&mut self, v: i64) {
        self.replication_count = v;
    }

    // .google.protobuf.Duration replication_timeout = 9;


    pub fn get_replication_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.replication_timeout.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_replication_timeout(&mut self) {
        self.replication_timeout.clear();
    }

    pub fn has_replication_timeout(&self) -> bool {
        self.replication_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.replication_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replication_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.replication_timeout.is_none() {
            self.replication_timeout.set_default();
        }
        self.replication_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_replication_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.replication_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration dial_timeout = 10;


    pub fn get_dial_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.dial_timeout.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_dial_timeout(&mut self) {
        self.dial_timeout.clear();
    }

    pub fn has_dial_timeout(&self) -> bool {
        self.dial_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dial_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.dial_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dial_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.dial_timeout.is_none() {
            self.dial_timeout.set_default();
        }
        self.dial_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_dial_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.dial_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration read_timeout = 11;


    pub fn get_read_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.read_timeout.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_read_timeout(&mut self) {
        self.read_timeout.clear();
    }

    pub fn has_read_timeout(&self) -> bool {
        self.read_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.read_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.read_timeout.is_none() {
            self.read_timeout.set_default();
        }
        self.read_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.read_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration write_timeout = 12;


    pub fn get_write_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.write_timeout.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_write_timeout(&mut self) {
        self.write_timeout.clear();
    }

    pub fn has_write_timeout(&self) -> bool {
        self.write_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_write_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.write_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_write_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.write_timeout.is_none() {
            self.write_timeout.set_default();
        }
        self.write_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_write_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.write_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for RedisBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        if let Some(RedisBlobAccessConfiguration_oneof_mode::clustered(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RedisBlobAccessConfiguration_oneof_mode::single(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.tls {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.replication_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dial_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.read_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.write_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::clustered(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(RedisBlobAccessConfiguration_oneof_mode::single(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tls)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replication_count = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.replication_timeout)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dial_timeout)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_timeout)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.write_timeout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tls.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.replication_count != 0 {
            my_size += ::protobuf::rt::value_size(8, self.replication_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.replication_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dial_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.read_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.write_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &RedisBlobAccessConfiguration_oneof_mode::clustered(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RedisBlobAccessConfiguration_oneof_mode::single(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tls.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.replication_count != 0 {
            os.write_int64(8, self.replication_count)?;
        }
        if let Some(ref v) = self.replication_timeout.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dial_timeout.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.read_timeout.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.write_timeout.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &RedisBlobAccessConfiguration_oneof_mode::clustered(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RedisBlobAccessConfiguration_oneof_mode::single(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedisBlobAccessConfiguration {
        RedisBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ClusteredRedisBlobAccessConfiguration>(
                    "clustered",
                    RedisBlobAccessConfiguration::has_clustered,
                    RedisBlobAccessConfiguration::get_clustered,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SingleRedisBlobAccessConfiguration>(
                    "single",
                    RedisBlobAccessConfiguration::has_single,
                    RedisBlobAccessConfiguration::get_single,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tls::ClientConfiguration>>(
                    "tls",
                    |m: &RedisBlobAccessConfiguration| { &m.tls },
                    |m: &mut RedisBlobAccessConfiguration| { &mut m.tls },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "replication_count",
                    |m: &RedisBlobAccessConfiguration| { &m.replication_count },
                    |m: &mut RedisBlobAccessConfiguration| { &mut m.replication_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "replication_timeout",
                    |m: &RedisBlobAccessConfiguration| { &m.replication_timeout },
                    |m: &mut RedisBlobAccessConfiguration| { &mut m.replication_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "dial_timeout",
                    |m: &RedisBlobAccessConfiguration| { &m.dial_timeout },
                    |m: &mut RedisBlobAccessConfiguration| { &mut m.dial_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "read_timeout",
                    |m: &RedisBlobAccessConfiguration| { &m.read_timeout },
                    |m: &mut RedisBlobAccessConfiguration| { &mut m.read_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "write_timeout",
                    |m: &RedisBlobAccessConfiguration| { &m.write_timeout },
                    |m: &mut RedisBlobAccessConfiguration| { &mut m.write_timeout },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RedisBlobAccessConfiguration>(
                    "RedisBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RedisBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<RedisBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RedisBlobAccessConfiguration,
        };
        unsafe {
            instance.get(RedisBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for RedisBlobAccessConfiguration {
    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.tls.clear();
        self.replication_count = 0;
        self.replication_timeout.clear();
        self.dial_timeout.clear();
        self.read_timeout.clear();
        self.write_timeout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedisBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedisBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPBlobAccessConfiguration {
    // message fields
    pub address: ::std::string::String,
    pub client: ::protobuf::SingularPtrField<super::http::ClientConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPBlobAccessConfiguration {
    fn default() -> &'a HTTPBlobAccessConfiguration {
        <HTTPBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl HTTPBlobAccessConfiguration {
    pub fn new() -> HTTPBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // .http.ClientConfiguration client = 2;


    pub fn get_client(&self) -> &super::http::ClientConfiguration {
        self.client.as_ref().unwrap_or_else(|| super::http::ClientConfiguration::default_instance())
    }
    pub fn clear_client(&mut self) {
        self.client.clear();
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: super::http::ClientConfiguration) {
        self.client = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&mut self) -> &mut super::http::ClientConfiguration {
        if self.client.is_none() {
            self.client.set_default();
        }
        self.client.as_mut().unwrap()
    }

    // Take field
    pub fn take_client(&mut self) -> super::http::ClientConfiguration {
        self.client.take().unwrap_or_else(|| super::http::ClientConfiguration::new())
    }
}

impl ::protobuf::Message for HTTPBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.client {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.client)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if let Some(ref v) = self.client.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if let Some(ref v) = self.client.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPBlobAccessConfiguration {
        HTTPBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &HTTPBlobAccessConfiguration| { &m.address },
                    |m: &mut HTTPBlobAccessConfiguration| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::http::ClientConfiguration>>(
                    "client",
                    |m: &HTTPBlobAccessConfiguration| { &m.client },
                    |m: &mut HTTPBlobAccessConfiguration| { &mut m.client },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTTPBlobAccessConfiguration>(
                    "HTTPBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HTTPBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<HTTPBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTTPBlobAccessConfiguration,
        };
        unsafe {
            instance.get(HTTPBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for HTTPBlobAccessConfiguration {
    fn clear(&mut self) {
        self.address.clear();
        self.client.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShardingBlobAccessConfiguration {
    // message fields
    pub hash_initialization: u64,
    pub shards: ::protobuf::RepeatedField<ShardingBlobAccessConfiguration_Shard>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShardingBlobAccessConfiguration {
    fn default() -> &'a ShardingBlobAccessConfiguration {
        <ShardingBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ShardingBlobAccessConfiguration {
    pub fn new() -> ShardingBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // uint64 hash_initialization = 1;


    pub fn get_hash_initialization(&self) -> u64 {
        self.hash_initialization
    }
    pub fn clear_hash_initialization(&mut self) {
        self.hash_initialization = 0;
    }

    // Param is passed by value, moved
    pub fn set_hash_initialization(&mut self, v: u64) {
        self.hash_initialization = v;
    }

    // repeated .blobstore.ShardingBlobAccessConfiguration.Shard shards = 2;


    pub fn get_shards(&self) -> &[ShardingBlobAccessConfiguration_Shard] {
        &self.shards
    }
    pub fn clear_shards(&mut self) {
        self.shards.clear();
    }

    // Param is passed by value, moved
    pub fn set_shards(&mut self, v: ::protobuf::RepeatedField<ShardingBlobAccessConfiguration_Shard>) {
        self.shards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shards(&mut self) -> &mut ::protobuf::RepeatedField<ShardingBlobAccessConfiguration_Shard> {
        &mut self.shards
    }

    // Take field
    pub fn take_shards(&mut self) -> ::protobuf::RepeatedField<ShardingBlobAccessConfiguration_Shard> {
        ::std::mem::replace(&mut self.shards, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ShardingBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.shards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hash_initialization = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.hash_initialization != 0 {
            my_size += ::protobuf::rt::value_size(1, self.hash_initialization, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.shards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.hash_initialization != 0 {
            os.write_uint64(1, self.hash_initialization)?;
        }
        for v in &self.shards {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardingBlobAccessConfiguration {
        ShardingBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "hash_initialization",
                    |m: &ShardingBlobAccessConfiguration| { &m.hash_initialization },
                    |m: &mut ShardingBlobAccessConfiguration| { &mut m.hash_initialization },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShardingBlobAccessConfiguration_Shard>>(
                    "shards",
                    |m: &ShardingBlobAccessConfiguration| { &m.shards },
                    |m: &mut ShardingBlobAccessConfiguration| { &mut m.shards },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ShardingBlobAccessConfiguration>(
                    "ShardingBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ShardingBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<ShardingBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ShardingBlobAccessConfiguration,
        };
        unsafe {
            instance.get(ShardingBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for ShardingBlobAccessConfiguration {
    fn clear(&mut self) {
        self.hash_initialization = 0;
        self.shards.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardingBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardingBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShardingBlobAccessConfiguration_Shard {
    // message fields
    pub backend: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub weight: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShardingBlobAccessConfiguration_Shard {
    fn default() -> &'a ShardingBlobAccessConfiguration_Shard {
        <ShardingBlobAccessConfiguration_Shard as ::protobuf::Message>::default_instance()
    }
}

impl ShardingBlobAccessConfiguration_Shard {
    pub fn new() -> ShardingBlobAccessConfiguration_Shard {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration backend = 1;


    pub fn get_backend(&self) -> &BlobAccessConfiguration {
        self.backend.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    pub fn has_backend(&self) -> bool {
        self.backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: BlobAccessConfiguration) {
        self.backend = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut BlobAccessConfiguration {
        if self.backend.is_none() {
            self.backend.set_default();
        }
        self.backend.as_mut().unwrap()
    }

    // Take field
    pub fn take_backend(&mut self) -> BlobAccessConfiguration {
        self.backend.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // uint32 weight = 2;


    pub fn get_weight(&self) -> u32 {
        self.weight
    }
    pub fn clear_weight(&mut self) {
        self.weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: u32) {
        self.weight = v;
    }
}

impl ::protobuf::Message for ShardingBlobAccessConfiguration_Shard {
    fn is_initialized(&self) -> bool {
        for v in &self.backend {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backend)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.weight = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.weight != 0 {
            my_size += ::protobuf::rt::value_size(2, self.weight, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backend.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.weight != 0 {
            os.write_uint32(2, self.weight)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardingBlobAccessConfiguration_Shard {
        ShardingBlobAccessConfiguration_Shard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "backend",
                    |m: &ShardingBlobAccessConfiguration_Shard| { &m.backend },
                    |m: &mut ShardingBlobAccessConfiguration_Shard| { &mut m.backend },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "weight",
                    |m: &ShardingBlobAccessConfiguration_Shard| { &m.weight },
                    |m: &mut ShardingBlobAccessConfiguration_Shard| { &mut m.weight },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ShardingBlobAccessConfiguration_Shard>(
                    "ShardingBlobAccessConfiguration_Shard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ShardingBlobAccessConfiguration_Shard {
        static mut instance: ::protobuf::lazy::Lazy<ShardingBlobAccessConfiguration_Shard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ShardingBlobAccessConfiguration_Shard,
        };
        unsafe {
            instance.get(ShardingBlobAccessConfiguration_Shard::new)
        }
    }
}

impl ::protobuf::Clear for ShardingBlobAccessConfiguration_Shard {
    fn clear(&mut self) {
        self.backend.clear();
        self.weight = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardingBlobAccessConfiguration_Shard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardingBlobAccessConfiguration_Shard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SizeDistinguishingBlobAccessConfiguration {
    // message fields
    pub small: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub large: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub cutoff_size_bytes: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SizeDistinguishingBlobAccessConfiguration {
    fn default() -> &'a SizeDistinguishingBlobAccessConfiguration {
        <SizeDistinguishingBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl SizeDistinguishingBlobAccessConfiguration {
    pub fn new() -> SizeDistinguishingBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration small = 1;


    pub fn get_small(&self) -> &BlobAccessConfiguration {
        self.small.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_small(&mut self) {
        self.small.clear();
    }

    pub fn has_small(&self) -> bool {
        self.small.is_some()
    }

    // Param is passed by value, moved
    pub fn set_small(&mut self, v: BlobAccessConfiguration) {
        self.small = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_small(&mut self) -> &mut BlobAccessConfiguration {
        if self.small.is_none() {
            self.small.set_default();
        }
        self.small.as_mut().unwrap()
    }

    // Take field
    pub fn take_small(&mut self) -> BlobAccessConfiguration {
        self.small.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .blobstore.BlobAccessConfiguration large = 2;


    pub fn get_large(&self) -> &BlobAccessConfiguration {
        self.large.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_large(&mut self) {
        self.large.clear();
    }

    pub fn has_large(&self) -> bool {
        self.large.is_some()
    }

    // Param is passed by value, moved
    pub fn set_large(&mut self, v: BlobAccessConfiguration) {
        self.large = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_large(&mut self) -> &mut BlobAccessConfiguration {
        if self.large.is_none() {
            self.large.set_default();
        }
        self.large.as_mut().unwrap()
    }

    // Take field
    pub fn take_large(&mut self) -> BlobAccessConfiguration {
        self.large.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // int64 cutoff_size_bytes = 3;


    pub fn get_cutoff_size_bytes(&self) -> i64 {
        self.cutoff_size_bytes
    }
    pub fn clear_cutoff_size_bytes(&mut self) {
        self.cutoff_size_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_cutoff_size_bytes(&mut self, v: i64) {
        self.cutoff_size_bytes = v;
    }
}

impl ::protobuf::Message for SizeDistinguishingBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.small {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.large {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.small)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.large)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cutoff_size_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.small.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.large.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.cutoff_size_bytes != 0 {
            my_size += ::protobuf::rt::value_size(3, self.cutoff_size_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.small.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.large.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.cutoff_size_bytes != 0 {
            os.write_int64(3, self.cutoff_size_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SizeDistinguishingBlobAccessConfiguration {
        SizeDistinguishingBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "small",
                    |m: &SizeDistinguishingBlobAccessConfiguration| { &m.small },
                    |m: &mut SizeDistinguishingBlobAccessConfiguration| { &mut m.small },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "large",
                    |m: &SizeDistinguishingBlobAccessConfiguration| { &m.large },
                    |m: &mut SizeDistinguishingBlobAccessConfiguration| { &mut m.large },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cutoff_size_bytes",
                    |m: &SizeDistinguishingBlobAccessConfiguration| { &m.cutoff_size_bytes },
                    |m: &mut SizeDistinguishingBlobAccessConfiguration| { &mut m.cutoff_size_bytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SizeDistinguishingBlobAccessConfiguration>(
                    "SizeDistinguishingBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SizeDistinguishingBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<SizeDistinguishingBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SizeDistinguishingBlobAccessConfiguration,
        };
        unsafe {
            instance.get(SizeDistinguishingBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for SizeDistinguishingBlobAccessConfiguration {
    fn clear(&mut self) {
        self.small.clear();
        self.large.clear();
        self.cutoff_size_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SizeDistinguishingBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SizeDistinguishingBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MirroredBlobAccessConfiguration {
    // message fields
    pub backend_a: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub backend_b: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub replicator_a_to_b: ::protobuf::SingularPtrField<BlobReplicatorConfiguration>,
    pub replicator_b_to_a: ::protobuf::SingularPtrField<BlobReplicatorConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MirroredBlobAccessConfiguration {
    fn default() -> &'a MirroredBlobAccessConfiguration {
        <MirroredBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl MirroredBlobAccessConfiguration {
    pub fn new() -> MirroredBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration backend_a = 1;


    pub fn get_backend_a(&self) -> &BlobAccessConfiguration {
        self.backend_a.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_backend_a(&mut self) {
        self.backend_a.clear();
    }

    pub fn has_backend_a(&self) -> bool {
        self.backend_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend_a(&mut self, v: BlobAccessConfiguration) {
        self.backend_a = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend_a(&mut self) -> &mut BlobAccessConfiguration {
        if self.backend_a.is_none() {
            self.backend_a.set_default();
        }
        self.backend_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_backend_a(&mut self) -> BlobAccessConfiguration {
        self.backend_a.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .blobstore.BlobAccessConfiguration backend_b = 2;


    pub fn get_backend_b(&self) -> &BlobAccessConfiguration {
        self.backend_b.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_backend_b(&mut self) {
        self.backend_b.clear();
    }

    pub fn has_backend_b(&self) -> bool {
        self.backend_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend_b(&mut self, v: BlobAccessConfiguration) {
        self.backend_b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend_b(&mut self) -> &mut BlobAccessConfiguration {
        if self.backend_b.is_none() {
            self.backend_b.set_default();
        }
        self.backend_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_backend_b(&mut self) -> BlobAccessConfiguration {
        self.backend_b.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .blobstore.BlobReplicatorConfiguration replicator_a_to_b = 3;


    pub fn get_replicator_a_to_b(&self) -> &BlobReplicatorConfiguration {
        self.replicator_a_to_b.as_ref().unwrap_or_else(|| BlobReplicatorConfiguration::default_instance())
    }
    pub fn clear_replicator_a_to_b(&mut self) {
        self.replicator_a_to_b.clear();
    }

    pub fn has_replicator_a_to_b(&self) -> bool {
        self.replicator_a_to_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicator_a_to_b(&mut self, v: BlobReplicatorConfiguration) {
        self.replicator_a_to_b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replicator_a_to_b(&mut self) -> &mut BlobReplicatorConfiguration {
        if self.replicator_a_to_b.is_none() {
            self.replicator_a_to_b.set_default();
        }
        self.replicator_a_to_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_replicator_a_to_b(&mut self) -> BlobReplicatorConfiguration {
        self.replicator_a_to_b.take().unwrap_or_else(|| BlobReplicatorConfiguration::new())
    }

    // .blobstore.BlobReplicatorConfiguration replicator_b_to_a = 4;


    pub fn get_replicator_b_to_a(&self) -> &BlobReplicatorConfiguration {
        self.replicator_b_to_a.as_ref().unwrap_or_else(|| BlobReplicatorConfiguration::default_instance())
    }
    pub fn clear_replicator_b_to_a(&mut self) {
        self.replicator_b_to_a.clear();
    }

    pub fn has_replicator_b_to_a(&self) -> bool {
        self.replicator_b_to_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicator_b_to_a(&mut self, v: BlobReplicatorConfiguration) {
        self.replicator_b_to_a = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replicator_b_to_a(&mut self) -> &mut BlobReplicatorConfiguration {
        if self.replicator_b_to_a.is_none() {
            self.replicator_b_to_a.set_default();
        }
        self.replicator_b_to_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_replicator_b_to_a(&mut self) -> BlobReplicatorConfiguration {
        self.replicator_b_to_a.take().unwrap_or_else(|| BlobReplicatorConfiguration::new())
    }
}

impl ::protobuf::Message for MirroredBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.backend_a {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.backend_b {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.replicator_a_to_b {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.replicator_b_to_a {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backend_a)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backend_b)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.replicator_a_to_b)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.replicator_b_to_a)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backend_a.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.backend_b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.replicator_a_to_b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.replicator_b_to_a.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backend_a.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.backend_b.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.replicator_a_to_b.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.replicator_b_to_a.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MirroredBlobAccessConfiguration {
        MirroredBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "backend_a",
                    |m: &MirroredBlobAccessConfiguration| { &m.backend_a },
                    |m: &mut MirroredBlobAccessConfiguration| { &mut m.backend_a },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "backend_b",
                    |m: &MirroredBlobAccessConfiguration| { &m.backend_b },
                    |m: &mut MirroredBlobAccessConfiguration| { &mut m.backend_b },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobReplicatorConfiguration>>(
                    "replicator_a_to_b",
                    |m: &MirroredBlobAccessConfiguration| { &m.replicator_a_to_b },
                    |m: &mut MirroredBlobAccessConfiguration| { &mut m.replicator_a_to_b },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobReplicatorConfiguration>>(
                    "replicator_b_to_a",
                    |m: &MirroredBlobAccessConfiguration| { &m.replicator_b_to_a },
                    |m: &mut MirroredBlobAccessConfiguration| { &mut m.replicator_b_to_a },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MirroredBlobAccessConfiguration>(
                    "MirroredBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MirroredBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<MirroredBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MirroredBlobAccessConfiguration,
        };
        unsafe {
            instance.get(MirroredBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for MirroredBlobAccessConfiguration {
    fn clear(&mut self) {
        self.backend_a.clear();
        self.backend_b.clear();
        self.replicator_a_to_b.clear();
        self.replicator_b_to_a.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MirroredBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MirroredBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalBlobAccessConfiguration {
    // message fields
    pub key_location_map_maximum_get_attempts: u32,
    pub key_location_map_maximum_put_attempts: i64,
    pub old_blocks: i32,
    pub current_blocks: i32,
    pub new_blocks: i32,
    pub persistent: ::protobuf::SingularPtrField<LocalBlobAccessConfiguration_Persistent>,
    pub hierarchical_instance_names: bool,
    // message oneof groups
    pub key_location_map_backend: ::std::option::Option<LocalBlobAccessConfiguration_oneof_key_location_map_backend>,
    pub blocks_backend: ::std::option::Option<LocalBlobAccessConfiguration_oneof_blocks_backend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalBlobAccessConfiguration {
    fn default() -> &'a LocalBlobAccessConfiguration {
        <LocalBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LocalBlobAccessConfiguration_oneof_key_location_map_backend {
    key_location_map_in_memory(LocalBlobAccessConfiguration_KeyLocationMapInMemory),
    key_location_map_on_block_device(super::blockdevice::Configuration),
}

#[derive(Clone,PartialEq,Debug)]
pub enum LocalBlobAccessConfiguration_oneof_blocks_backend {
    blocks_in_memory(LocalBlobAccessConfiguration_BlocksInMemory),
    blocks_on_block_device(LocalBlobAccessConfiguration_BlocksOnBlockDevice),
}

impl LocalBlobAccessConfiguration {
    pub fn new() -> LocalBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.LocalBlobAccessConfiguration.KeyLocationMapInMemory key_location_map_in_memory = 11;


    pub fn get_key_location_map_in_memory(&self) -> &LocalBlobAccessConfiguration_KeyLocationMapInMemory {
        match self.key_location_map_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(ref v)) => v,
            _ => LocalBlobAccessConfiguration_KeyLocationMapInMemory::default_instance(),
        }
    }
    pub fn clear_key_location_map_in_memory(&mut self) {
        self.key_location_map_backend = ::std::option::Option::None;
    }

    pub fn has_key_location_map_in_memory(&self) -> bool {
        match self.key_location_map_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_location_map_in_memory(&mut self, v: LocalBlobAccessConfiguration_KeyLocationMapInMemory) {
        self.key_location_map_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_location_map_in_memory(&mut self) -> &mut LocalBlobAccessConfiguration_KeyLocationMapInMemory {
        if let ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(_)) = self.key_location_map_backend {
        } else {
            self.key_location_map_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(LocalBlobAccessConfiguration_KeyLocationMapInMemory::new()));
        }
        match self.key_location_map_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_location_map_in_memory(&mut self) -> LocalBlobAccessConfiguration_KeyLocationMapInMemory {
        if self.has_key_location_map_in_memory() {
            match self.key_location_map_backend.take() {
                ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(v)) => v,
                _ => panic!(),
            }
        } else {
            LocalBlobAccessConfiguration_KeyLocationMapInMemory::new()
        }
    }

    // .blockdevice.Configuration key_location_map_on_block_device = 12;


    pub fn get_key_location_map_on_block_device(&self) -> &super::blockdevice::Configuration {
        match self.key_location_map_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(ref v)) => v,
            _ => super::blockdevice::Configuration::default_instance(),
        }
    }
    pub fn clear_key_location_map_on_block_device(&mut self) {
        self.key_location_map_backend = ::std::option::Option::None;
    }

    pub fn has_key_location_map_on_block_device(&self) -> bool {
        match self.key_location_map_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_location_map_on_block_device(&mut self, v: super::blockdevice::Configuration) {
        self.key_location_map_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_location_map_on_block_device(&mut self) -> &mut super::blockdevice::Configuration {
        if let ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(_)) = self.key_location_map_backend {
        } else {
            self.key_location_map_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(super::blockdevice::Configuration::new()));
        }
        match self.key_location_map_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_location_map_on_block_device(&mut self) -> super::blockdevice::Configuration {
        if self.has_key_location_map_on_block_device() {
            match self.key_location_map_backend.take() {
                ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(v)) => v,
                _ => panic!(),
            }
        } else {
            super::blockdevice::Configuration::new()
        }
    }

    // uint32 key_location_map_maximum_get_attempts = 2;


    pub fn get_key_location_map_maximum_get_attempts(&self) -> u32 {
        self.key_location_map_maximum_get_attempts
    }
    pub fn clear_key_location_map_maximum_get_attempts(&mut self) {
        self.key_location_map_maximum_get_attempts = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_location_map_maximum_get_attempts(&mut self, v: u32) {
        self.key_location_map_maximum_get_attempts = v;
    }

    // int64 key_location_map_maximum_put_attempts = 3;


    pub fn get_key_location_map_maximum_put_attempts(&self) -> i64 {
        self.key_location_map_maximum_put_attempts
    }
    pub fn clear_key_location_map_maximum_put_attempts(&mut self) {
        self.key_location_map_maximum_put_attempts = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_location_map_maximum_put_attempts(&mut self, v: i64) {
        self.key_location_map_maximum_put_attempts = v;
    }

    // int32 old_blocks = 5;


    pub fn get_old_blocks(&self) -> i32 {
        self.old_blocks
    }
    pub fn clear_old_blocks(&mut self) {
        self.old_blocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_old_blocks(&mut self, v: i32) {
        self.old_blocks = v;
    }

    // int32 current_blocks = 6;


    pub fn get_current_blocks(&self) -> i32 {
        self.current_blocks
    }
    pub fn clear_current_blocks(&mut self) {
        self.current_blocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_blocks(&mut self, v: i32) {
        self.current_blocks = v;
    }

    // int32 new_blocks = 7;


    pub fn get_new_blocks(&self) -> i32 {
        self.new_blocks
    }
    pub fn clear_new_blocks(&mut self) {
        self.new_blocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_blocks(&mut self, v: i32) {
        self.new_blocks = v;
    }

    // .blobstore.LocalBlobAccessConfiguration.BlocksInMemory blocks_in_memory = 9;


    pub fn get_blocks_in_memory(&self) -> &LocalBlobAccessConfiguration_BlocksInMemory {
        match self.blocks_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(ref v)) => v,
            _ => LocalBlobAccessConfiguration_BlocksInMemory::default_instance(),
        }
    }
    pub fn clear_blocks_in_memory(&mut self) {
        self.blocks_backend = ::std::option::Option::None;
    }

    pub fn has_blocks_in_memory(&self) -> bool {
        match self.blocks_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_blocks_in_memory(&mut self, v: LocalBlobAccessConfiguration_BlocksInMemory) {
        self.blocks_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(v))
    }

    // Mutable pointer to the field.
    pub fn mut_blocks_in_memory(&mut self) -> &mut LocalBlobAccessConfiguration_BlocksInMemory {
        if let ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(_)) = self.blocks_backend {
        } else {
            self.blocks_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(LocalBlobAccessConfiguration_BlocksInMemory::new()));
        }
        match self.blocks_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_blocks_in_memory(&mut self) -> LocalBlobAccessConfiguration_BlocksInMemory {
        if self.has_blocks_in_memory() {
            match self.blocks_backend.take() {
                ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(v)) => v,
                _ => panic!(),
            }
        } else {
            LocalBlobAccessConfiguration_BlocksInMemory::new()
        }
    }

    // .blobstore.LocalBlobAccessConfiguration.BlocksOnBlockDevice blocks_on_block_device = 10;


    pub fn get_blocks_on_block_device(&self) -> &LocalBlobAccessConfiguration_BlocksOnBlockDevice {
        match self.blocks_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(ref v)) => v,
            _ => LocalBlobAccessConfiguration_BlocksOnBlockDevice::default_instance(),
        }
    }
    pub fn clear_blocks_on_block_device(&mut self) {
        self.blocks_backend = ::std::option::Option::None;
    }

    pub fn has_blocks_on_block_device(&self) -> bool {
        match self.blocks_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_blocks_on_block_device(&mut self, v: LocalBlobAccessConfiguration_BlocksOnBlockDevice) {
        self.blocks_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(v))
    }

    // Mutable pointer to the field.
    pub fn mut_blocks_on_block_device(&mut self) -> &mut LocalBlobAccessConfiguration_BlocksOnBlockDevice {
        if let ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(_)) = self.blocks_backend {
        } else {
            self.blocks_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(LocalBlobAccessConfiguration_BlocksOnBlockDevice::new()));
        }
        match self.blocks_backend {
            ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_blocks_on_block_device(&mut self) -> LocalBlobAccessConfiguration_BlocksOnBlockDevice {
        if self.has_blocks_on_block_device() {
            match self.blocks_backend.take() {
                ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(v)) => v,
                _ => panic!(),
            }
        } else {
            LocalBlobAccessConfiguration_BlocksOnBlockDevice::new()
        }
    }

    // .blobstore.LocalBlobAccessConfiguration.Persistent persistent = 13;


    pub fn get_persistent(&self) -> &LocalBlobAccessConfiguration_Persistent {
        self.persistent.as_ref().unwrap_or_else(|| LocalBlobAccessConfiguration_Persistent::default_instance())
    }
    pub fn clear_persistent(&mut self) {
        self.persistent.clear();
    }

    pub fn has_persistent(&self) -> bool {
        self.persistent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistent(&mut self, v: LocalBlobAccessConfiguration_Persistent) {
        self.persistent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistent(&mut self) -> &mut LocalBlobAccessConfiguration_Persistent {
        if self.persistent.is_none() {
            self.persistent.set_default();
        }
        self.persistent.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistent(&mut self) -> LocalBlobAccessConfiguration_Persistent {
        self.persistent.take().unwrap_or_else(|| LocalBlobAccessConfiguration_Persistent::new())
    }

    // bool hierarchical_instance_names = 14;


    pub fn get_hierarchical_instance_names(&self) -> bool {
        self.hierarchical_instance_names
    }
    pub fn clear_hierarchical_instance_names(&mut self) {
        self.hierarchical_instance_names = false;
    }

    // Param is passed by value, moved
    pub fn set_hierarchical_instance_names(&mut self, v: bool) {
        self.hierarchical_instance_names = v;
    }
}

impl ::protobuf::Message for LocalBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        if let Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(ref v)) = self.key_location_map_backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(ref v)) = self.key_location_map_backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(ref v)) = self.blocks_backend {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(ref v)) = self.blocks_backend {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.persistent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key_location_map_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key_location_map_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.key_location_map_maximum_get_attempts = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.key_location_map_maximum_put_attempts = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.old_blocks = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_blocks = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.new_blocks = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.blocks_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.blocks_backend = ::std::option::Option::Some(LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(is.read_message()?));
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistent)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hierarchical_instance_names = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_location_map_maximum_get_attempts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.key_location_map_maximum_get_attempts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.key_location_map_maximum_put_attempts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.key_location_map_maximum_put_attempts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.old_blocks != 0 {
            my_size += ::protobuf::rt::value_size(5, self.old_blocks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.current_blocks != 0 {
            my_size += ::protobuf::rt::value_size(6, self.current_blocks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.new_blocks != 0 {
            my_size += ::protobuf::rt::value_size(7, self.new_blocks, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.persistent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.hierarchical_instance_names != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.key_location_map_backend {
            match v {
                &LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.blocks_backend {
            match v {
                &LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_location_map_maximum_get_attempts != 0 {
            os.write_uint32(2, self.key_location_map_maximum_get_attempts)?;
        }
        if self.key_location_map_maximum_put_attempts != 0 {
            os.write_int64(3, self.key_location_map_maximum_put_attempts)?;
        }
        if self.old_blocks != 0 {
            os.write_int32(5, self.old_blocks)?;
        }
        if self.current_blocks != 0 {
            os.write_int32(6, self.current_blocks)?;
        }
        if self.new_blocks != 0 {
            os.write_int32(7, self.new_blocks)?;
        }
        if let Some(ref v) = self.persistent.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.hierarchical_instance_names != false {
            os.write_bool(14, self.hierarchical_instance_names)?;
        }
        if let ::std::option::Option::Some(ref v) = self.key_location_map_backend {
            match v {
                &LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_in_memory(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &LocalBlobAccessConfiguration_oneof_key_location_map_backend::key_location_map_on_block_device(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.blocks_backend {
            match v {
                &LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_in_memory(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &LocalBlobAccessConfiguration_oneof_blocks_backend::blocks_on_block_device(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalBlobAccessConfiguration {
        LocalBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LocalBlobAccessConfiguration_KeyLocationMapInMemory>(
                    "key_location_map_in_memory",
                    LocalBlobAccessConfiguration::has_key_location_map_in_memory,
                    LocalBlobAccessConfiguration::get_key_location_map_in_memory,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::blockdevice::Configuration>(
                    "key_location_map_on_block_device",
                    LocalBlobAccessConfiguration::has_key_location_map_on_block_device,
                    LocalBlobAccessConfiguration::get_key_location_map_on_block_device,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "key_location_map_maximum_get_attempts",
                    |m: &LocalBlobAccessConfiguration| { &m.key_location_map_maximum_get_attempts },
                    |m: &mut LocalBlobAccessConfiguration| { &mut m.key_location_map_maximum_get_attempts },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "key_location_map_maximum_put_attempts",
                    |m: &LocalBlobAccessConfiguration| { &m.key_location_map_maximum_put_attempts },
                    |m: &mut LocalBlobAccessConfiguration| { &mut m.key_location_map_maximum_put_attempts },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "old_blocks",
                    |m: &LocalBlobAccessConfiguration| { &m.old_blocks },
                    |m: &mut LocalBlobAccessConfiguration| { &mut m.old_blocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "current_blocks",
                    |m: &LocalBlobAccessConfiguration| { &m.current_blocks },
                    |m: &mut LocalBlobAccessConfiguration| { &mut m.current_blocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "new_blocks",
                    |m: &LocalBlobAccessConfiguration| { &m.new_blocks },
                    |m: &mut LocalBlobAccessConfiguration| { &mut m.new_blocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LocalBlobAccessConfiguration_BlocksInMemory>(
                    "blocks_in_memory",
                    LocalBlobAccessConfiguration::has_blocks_in_memory,
                    LocalBlobAccessConfiguration::get_blocks_in_memory,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LocalBlobAccessConfiguration_BlocksOnBlockDevice>(
                    "blocks_on_block_device",
                    LocalBlobAccessConfiguration::has_blocks_on_block_device,
                    LocalBlobAccessConfiguration::get_blocks_on_block_device,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalBlobAccessConfiguration_Persistent>>(
                    "persistent",
                    |m: &LocalBlobAccessConfiguration| { &m.persistent },
                    |m: &mut LocalBlobAccessConfiguration| { &mut m.persistent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hierarchical_instance_names",
                    |m: &LocalBlobAccessConfiguration| { &m.hierarchical_instance_names },
                    |m: &mut LocalBlobAccessConfiguration| { &mut m.hierarchical_instance_names },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocalBlobAccessConfiguration>(
                    "LocalBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocalBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<LocalBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocalBlobAccessConfiguration,
        };
        unsafe {
            instance.get(LocalBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for LocalBlobAccessConfiguration {
    fn clear(&mut self) {
        self.key_location_map_backend = ::std::option::Option::None;
        self.key_location_map_backend = ::std::option::Option::None;
        self.key_location_map_maximum_get_attempts = 0;
        self.key_location_map_maximum_put_attempts = 0;
        self.old_blocks = 0;
        self.current_blocks = 0;
        self.new_blocks = 0;
        self.blocks_backend = ::std::option::Option::None;
        self.blocks_backend = ::std::option::Option::None;
        self.persistent.clear();
        self.hierarchical_instance_names = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalBlobAccessConfiguration_KeyLocationMapInMemory {
    // message fields
    pub entries: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalBlobAccessConfiguration_KeyLocationMapInMemory {
    fn default() -> &'a LocalBlobAccessConfiguration_KeyLocationMapInMemory {
        <LocalBlobAccessConfiguration_KeyLocationMapInMemory as ::protobuf::Message>::default_instance()
    }
}

impl LocalBlobAccessConfiguration_KeyLocationMapInMemory {
    pub fn new() -> LocalBlobAccessConfiguration_KeyLocationMapInMemory {
        ::std::default::Default::default()
    }

    // int64 entries = 1;


    pub fn get_entries(&self) -> i64 {
        self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries = 0;
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: i64) {
        self.entries = v;
    }
}

impl ::protobuf::Message for LocalBlobAccessConfiguration_KeyLocationMapInMemory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.entries = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.entries != 0 {
            my_size += ::protobuf::rt::value_size(1, self.entries, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.entries != 0 {
            os.write_int64(1, self.entries)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalBlobAccessConfiguration_KeyLocationMapInMemory {
        LocalBlobAccessConfiguration_KeyLocationMapInMemory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "entries",
                    |m: &LocalBlobAccessConfiguration_KeyLocationMapInMemory| { &m.entries },
                    |m: &mut LocalBlobAccessConfiguration_KeyLocationMapInMemory| { &mut m.entries },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocalBlobAccessConfiguration_KeyLocationMapInMemory>(
                    "LocalBlobAccessConfiguration_KeyLocationMapInMemory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocalBlobAccessConfiguration_KeyLocationMapInMemory {
        static mut instance: ::protobuf::lazy::Lazy<LocalBlobAccessConfiguration_KeyLocationMapInMemory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocalBlobAccessConfiguration_KeyLocationMapInMemory,
        };
        unsafe {
            instance.get(LocalBlobAccessConfiguration_KeyLocationMapInMemory::new)
        }
    }
}

impl ::protobuf::Clear for LocalBlobAccessConfiguration_KeyLocationMapInMemory {
    fn clear(&mut self) {
        self.entries = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalBlobAccessConfiguration_KeyLocationMapInMemory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalBlobAccessConfiguration_KeyLocationMapInMemory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalBlobAccessConfiguration_BlocksInMemory {
    // message fields
    pub block_size_bytes: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalBlobAccessConfiguration_BlocksInMemory {
    fn default() -> &'a LocalBlobAccessConfiguration_BlocksInMemory {
        <LocalBlobAccessConfiguration_BlocksInMemory as ::protobuf::Message>::default_instance()
    }
}

impl LocalBlobAccessConfiguration_BlocksInMemory {
    pub fn new() -> LocalBlobAccessConfiguration_BlocksInMemory {
        ::std::default::Default::default()
    }

    // int64 block_size_bytes = 1;


    pub fn get_block_size_bytes(&self) -> i64 {
        self.block_size_bytes
    }
    pub fn clear_block_size_bytes(&mut self) {
        self.block_size_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_size_bytes(&mut self, v: i64) {
        self.block_size_bytes = v;
    }
}

impl ::protobuf::Message for LocalBlobAccessConfiguration_BlocksInMemory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.block_size_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.block_size_bytes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.block_size_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.block_size_bytes != 0 {
            os.write_int64(1, self.block_size_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalBlobAccessConfiguration_BlocksInMemory {
        LocalBlobAccessConfiguration_BlocksInMemory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "block_size_bytes",
                    |m: &LocalBlobAccessConfiguration_BlocksInMemory| { &m.block_size_bytes },
                    |m: &mut LocalBlobAccessConfiguration_BlocksInMemory| { &mut m.block_size_bytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocalBlobAccessConfiguration_BlocksInMemory>(
                    "LocalBlobAccessConfiguration_BlocksInMemory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocalBlobAccessConfiguration_BlocksInMemory {
        static mut instance: ::protobuf::lazy::Lazy<LocalBlobAccessConfiguration_BlocksInMemory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocalBlobAccessConfiguration_BlocksInMemory,
        };
        unsafe {
            instance.get(LocalBlobAccessConfiguration_BlocksInMemory::new)
        }
    }
}

impl ::protobuf::Clear for LocalBlobAccessConfiguration_BlocksInMemory {
    fn clear(&mut self) {
        self.block_size_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalBlobAccessConfiguration_BlocksInMemory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalBlobAccessConfiguration_BlocksInMemory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalBlobAccessConfiguration_BlocksOnBlockDevice {
    // message fields
    pub source: ::protobuf::SingularPtrField<super::blockdevice::Configuration>,
    pub spare_blocks: i32,
    pub data_integrity_validation_cache: ::protobuf::SingularPtrField<super::digest::ExistenceCacheConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalBlobAccessConfiguration_BlocksOnBlockDevice {
    fn default() -> &'a LocalBlobAccessConfiguration_BlocksOnBlockDevice {
        <LocalBlobAccessConfiguration_BlocksOnBlockDevice as ::protobuf::Message>::default_instance()
    }
}

impl LocalBlobAccessConfiguration_BlocksOnBlockDevice {
    pub fn new() -> LocalBlobAccessConfiguration_BlocksOnBlockDevice {
        ::std::default::Default::default()
    }

    // .blockdevice.Configuration source = 1;


    pub fn get_source(&self) -> &super::blockdevice::Configuration {
        self.source.as_ref().unwrap_or_else(|| super::blockdevice::Configuration::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: super::blockdevice::Configuration) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut super::blockdevice::Configuration {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> super::blockdevice::Configuration {
        self.source.take().unwrap_or_else(|| super::blockdevice::Configuration::new())
    }

    // int32 spare_blocks = 2;


    pub fn get_spare_blocks(&self) -> i32 {
        self.spare_blocks
    }
    pub fn clear_spare_blocks(&mut self) {
        self.spare_blocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_spare_blocks(&mut self, v: i32) {
        self.spare_blocks = v;
    }

    // .digest.ExistenceCacheConfiguration data_integrity_validation_cache = 3;


    pub fn get_data_integrity_validation_cache(&self) -> &super::digest::ExistenceCacheConfiguration {
        self.data_integrity_validation_cache.as_ref().unwrap_or_else(|| super::digest::ExistenceCacheConfiguration::default_instance())
    }
    pub fn clear_data_integrity_validation_cache(&mut self) {
        self.data_integrity_validation_cache.clear();
    }

    pub fn has_data_integrity_validation_cache(&self) -> bool {
        self.data_integrity_validation_cache.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_integrity_validation_cache(&mut self, v: super::digest::ExistenceCacheConfiguration) {
        self.data_integrity_validation_cache = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_integrity_validation_cache(&mut self) -> &mut super::digest::ExistenceCacheConfiguration {
        if self.data_integrity_validation_cache.is_none() {
            self.data_integrity_validation_cache.set_default();
        }
        self.data_integrity_validation_cache.as_mut().unwrap()
    }

    // Take field
    pub fn take_data_integrity_validation_cache(&mut self) -> super::digest::ExistenceCacheConfiguration {
        self.data_integrity_validation_cache.take().unwrap_or_else(|| super::digest::ExistenceCacheConfiguration::new())
    }
}

impl ::protobuf::Message for LocalBlobAccessConfiguration_BlocksOnBlockDevice {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data_integrity_validation_cache {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.spare_blocks = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data_integrity_validation_cache)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.spare_blocks != 0 {
            my_size += ::protobuf::rt::value_size(2, self.spare_blocks, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data_integrity_validation_cache.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.spare_blocks != 0 {
            os.write_int32(2, self.spare_blocks)?;
        }
        if let Some(ref v) = self.data_integrity_validation_cache.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalBlobAccessConfiguration_BlocksOnBlockDevice {
        LocalBlobAccessConfiguration_BlocksOnBlockDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::blockdevice::Configuration>>(
                    "source",
                    |m: &LocalBlobAccessConfiguration_BlocksOnBlockDevice| { &m.source },
                    |m: &mut LocalBlobAccessConfiguration_BlocksOnBlockDevice| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "spare_blocks",
                    |m: &LocalBlobAccessConfiguration_BlocksOnBlockDevice| { &m.spare_blocks },
                    |m: &mut LocalBlobAccessConfiguration_BlocksOnBlockDevice| { &mut m.spare_blocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::digest::ExistenceCacheConfiguration>>(
                    "data_integrity_validation_cache",
                    |m: &LocalBlobAccessConfiguration_BlocksOnBlockDevice| { &m.data_integrity_validation_cache },
                    |m: &mut LocalBlobAccessConfiguration_BlocksOnBlockDevice| { &mut m.data_integrity_validation_cache },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocalBlobAccessConfiguration_BlocksOnBlockDevice>(
                    "LocalBlobAccessConfiguration_BlocksOnBlockDevice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocalBlobAccessConfiguration_BlocksOnBlockDevice {
        static mut instance: ::protobuf::lazy::Lazy<LocalBlobAccessConfiguration_BlocksOnBlockDevice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocalBlobAccessConfiguration_BlocksOnBlockDevice,
        };
        unsafe {
            instance.get(LocalBlobAccessConfiguration_BlocksOnBlockDevice::new)
        }
    }
}

impl ::protobuf::Clear for LocalBlobAccessConfiguration_BlocksOnBlockDevice {
    fn clear(&mut self) {
        self.source.clear();
        self.spare_blocks = 0;
        self.data_integrity_validation_cache.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalBlobAccessConfiguration_BlocksOnBlockDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalBlobAccessConfiguration_BlocksOnBlockDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalBlobAccessConfiguration_Persistent {
    // message fields
    pub state_directory_path: ::std::string::String,
    pub minimum_epoch_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalBlobAccessConfiguration_Persistent {
    fn default() -> &'a LocalBlobAccessConfiguration_Persistent {
        <LocalBlobAccessConfiguration_Persistent as ::protobuf::Message>::default_instance()
    }
}

impl LocalBlobAccessConfiguration_Persistent {
    pub fn new() -> LocalBlobAccessConfiguration_Persistent {
        ::std::default::Default::default()
    }

    // string state_directory_path = 1;


    pub fn get_state_directory_path(&self) -> &str {
        &self.state_directory_path
    }
    pub fn clear_state_directory_path(&mut self) {
        self.state_directory_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_state_directory_path(&mut self, v: ::std::string::String) {
        self.state_directory_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_directory_path(&mut self) -> &mut ::std::string::String {
        &mut self.state_directory_path
    }

    // Take field
    pub fn take_state_directory_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state_directory_path, ::std::string::String::new())
    }

    // .google.protobuf.Duration minimum_epoch_interval = 2;


    pub fn get_minimum_epoch_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.minimum_epoch_interval.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_minimum_epoch_interval(&mut self) {
        self.minimum_epoch_interval.clear();
    }

    pub fn has_minimum_epoch_interval(&self) -> bool {
        self.minimum_epoch_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum_epoch_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.minimum_epoch_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimum_epoch_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.minimum_epoch_interval.is_none() {
            self.minimum_epoch_interval.set_default();
        }
        self.minimum_epoch_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimum_epoch_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.minimum_epoch_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for LocalBlobAccessConfiguration_Persistent {
    fn is_initialized(&self) -> bool {
        for v in &self.minimum_epoch_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state_directory_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.minimum_epoch_interval)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.state_directory_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.state_directory_path);
        }
        if let Some(ref v) = self.minimum_epoch_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.state_directory_path.is_empty() {
            os.write_string(1, &self.state_directory_path)?;
        }
        if let Some(ref v) = self.minimum_epoch_interval.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalBlobAccessConfiguration_Persistent {
        LocalBlobAccessConfiguration_Persistent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "state_directory_path",
                    |m: &LocalBlobAccessConfiguration_Persistent| { &m.state_directory_path },
                    |m: &mut LocalBlobAccessConfiguration_Persistent| { &mut m.state_directory_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "minimum_epoch_interval",
                    |m: &LocalBlobAccessConfiguration_Persistent| { &m.minimum_epoch_interval },
                    |m: &mut LocalBlobAccessConfiguration_Persistent| { &mut m.minimum_epoch_interval },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocalBlobAccessConfiguration_Persistent>(
                    "LocalBlobAccessConfiguration_Persistent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocalBlobAccessConfiguration_Persistent {
        static mut instance: ::protobuf::lazy::Lazy<LocalBlobAccessConfiguration_Persistent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocalBlobAccessConfiguration_Persistent,
        };
        unsafe {
            instance.get(LocalBlobAccessConfiguration_Persistent::new)
        }
    }
}

impl ::protobuf::Clear for LocalBlobAccessConfiguration_Persistent {
    fn clear(&mut self) {
        self.state_directory_path.clear();
        self.minimum_epoch_interval.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalBlobAccessConfiguration_Persistent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalBlobAccessConfiguration_Persistent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExistenceCachingBlobAccessConfiguration {
    // message fields
    pub backend: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub existence_cache: ::protobuf::SingularPtrField<super::digest::ExistenceCacheConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExistenceCachingBlobAccessConfiguration {
    fn default() -> &'a ExistenceCachingBlobAccessConfiguration {
        <ExistenceCachingBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ExistenceCachingBlobAccessConfiguration {
    pub fn new() -> ExistenceCachingBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration backend = 1;


    pub fn get_backend(&self) -> &BlobAccessConfiguration {
        self.backend.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    pub fn has_backend(&self) -> bool {
        self.backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: BlobAccessConfiguration) {
        self.backend = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut BlobAccessConfiguration {
        if self.backend.is_none() {
            self.backend.set_default();
        }
        self.backend.as_mut().unwrap()
    }

    // Take field
    pub fn take_backend(&mut self) -> BlobAccessConfiguration {
        self.backend.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .digest.ExistenceCacheConfiguration existence_cache = 2;


    pub fn get_existence_cache(&self) -> &super::digest::ExistenceCacheConfiguration {
        self.existence_cache.as_ref().unwrap_or_else(|| super::digest::ExistenceCacheConfiguration::default_instance())
    }
    pub fn clear_existence_cache(&mut self) {
        self.existence_cache.clear();
    }

    pub fn has_existence_cache(&self) -> bool {
        self.existence_cache.is_some()
    }

    // Param is passed by value, moved
    pub fn set_existence_cache(&mut self, v: super::digest::ExistenceCacheConfiguration) {
        self.existence_cache = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_existence_cache(&mut self) -> &mut super::digest::ExistenceCacheConfiguration {
        if self.existence_cache.is_none() {
            self.existence_cache.set_default();
        }
        self.existence_cache.as_mut().unwrap()
    }

    // Take field
    pub fn take_existence_cache(&mut self) -> super::digest::ExistenceCacheConfiguration {
        self.existence_cache.take().unwrap_or_else(|| super::digest::ExistenceCacheConfiguration::new())
    }
}

impl ::protobuf::Message for ExistenceCachingBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.backend {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.existence_cache {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backend)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.existence_cache)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.existence_cache.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backend.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.existence_cache.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExistenceCachingBlobAccessConfiguration {
        ExistenceCachingBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "backend",
                    |m: &ExistenceCachingBlobAccessConfiguration| { &m.backend },
                    |m: &mut ExistenceCachingBlobAccessConfiguration| { &mut m.backend },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::digest::ExistenceCacheConfiguration>>(
                    "existence_cache",
                    |m: &ExistenceCachingBlobAccessConfiguration| { &m.existence_cache },
                    |m: &mut ExistenceCachingBlobAccessConfiguration| { &mut m.existence_cache },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExistenceCachingBlobAccessConfiguration>(
                    "ExistenceCachingBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExistenceCachingBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<ExistenceCachingBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExistenceCachingBlobAccessConfiguration,
        };
        unsafe {
            instance.get(ExistenceCachingBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for ExistenceCachingBlobAccessConfiguration {
    fn clear(&mut self) {
        self.backend.clear();
        self.existence_cache.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExistenceCachingBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExistenceCachingBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadFallbackBlobAccessConfiguration {
    // message fields
    pub primary: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub secondary: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub replicator: ::protobuf::SingularPtrField<BlobReplicatorConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadFallbackBlobAccessConfiguration {
    fn default() -> &'a ReadFallbackBlobAccessConfiguration {
        <ReadFallbackBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ReadFallbackBlobAccessConfiguration {
    pub fn new() -> ReadFallbackBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration primary = 1;


    pub fn get_primary(&self) -> &BlobAccessConfiguration {
        self.primary.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_primary(&mut self) {
        self.primary.clear();
    }

    pub fn has_primary(&self) -> bool {
        self.primary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary(&mut self, v: BlobAccessConfiguration) {
        self.primary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary(&mut self) -> &mut BlobAccessConfiguration {
        if self.primary.is_none() {
            self.primary.set_default();
        }
        self.primary.as_mut().unwrap()
    }

    // Take field
    pub fn take_primary(&mut self) -> BlobAccessConfiguration {
        self.primary.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .blobstore.BlobAccessConfiguration secondary = 2;


    pub fn get_secondary(&self) -> &BlobAccessConfiguration {
        self.secondary.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_secondary(&mut self) {
        self.secondary.clear();
    }

    pub fn has_secondary(&self) -> bool {
        self.secondary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary(&mut self, v: BlobAccessConfiguration) {
        self.secondary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secondary(&mut self) -> &mut BlobAccessConfiguration {
        if self.secondary.is_none() {
            self.secondary.set_default();
        }
        self.secondary.as_mut().unwrap()
    }

    // Take field
    pub fn take_secondary(&mut self) -> BlobAccessConfiguration {
        self.secondary.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .blobstore.BlobReplicatorConfiguration replicator = 3;


    pub fn get_replicator(&self) -> &BlobReplicatorConfiguration {
        self.replicator.as_ref().unwrap_or_else(|| BlobReplicatorConfiguration::default_instance())
    }
    pub fn clear_replicator(&mut self) {
        self.replicator.clear();
    }

    pub fn has_replicator(&self) -> bool {
        self.replicator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicator(&mut self, v: BlobReplicatorConfiguration) {
        self.replicator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replicator(&mut self) -> &mut BlobReplicatorConfiguration {
        if self.replicator.is_none() {
            self.replicator.set_default();
        }
        self.replicator.as_mut().unwrap()
    }

    // Take field
    pub fn take_replicator(&mut self) -> BlobReplicatorConfiguration {
        self.replicator.take().unwrap_or_else(|| BlobReplicatorConfiguration::new())
    }
}

impl ::protobuf::Message for ReadFallbackBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.primary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secondary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.replicator {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.primary)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secondary)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.replicator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.primary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.secondary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.replicator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.primary.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.secondary.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.replicator.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadFallbackBlobAccessConfiguration {
        ReadFallbackBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "primary",
                    |m: &ReadFallbackBlobAccessConfiguration| { &m.primary },
                    |m: &mut ReadFallbackBlobAccessConfiguration| { &mut m.primary },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "secondary",
                    |m: &ReadFallbackBlobAccessConfiguration| { &m.secondary },
                    |m: &mut ReadFallbackBlobAccessConfiguration| { &mut m.secondary },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobReplicatorConfiguration>>(
                    "replicator",
                    |m: &ReadFallbackBlobAccessConfiguration| { &m.replicator },
                    |m: &mut ReadFallbackBlobAccessConfiguration| { &mut m.replicator },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadFallbackBlobAccessConfiguration>(
                    "ReadFallbackBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadFallbackBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<ReadFallbackBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadFallbackBlobAccessConfiguration,
        };
        unsafe {
            instance.get(ReadFallbackBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for ReadFallbackBlobAccessConfiguration {
    fn clear(&mut self) {
        self.primary.clear();
        self.secondary.clear();
        self.replicator.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadFallbackBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadFallbackBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReferenceExpandingBlobAccessConfiguration {
    // message fields
    pub indirect_content_addressable_storage: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub aws_session: ::protobuf::SingularPtrField<super::aws::SessionConfiguration>,
    pub http_client: ::protobuf::SingularPtrField<super::http::ClientConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReferenceExpandingBlobAccessConfiguration {
    fn default() -> &'a ReferenceExpandingBlobAccessConfiguration {
        <ReferenceExpandingBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ReferenceExpandingBlobAccessConfiguration {
    pub fn new() -> ReferenceExpandingBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration indirect_content_addressable_storage = 1;


    pub fn get_indirect_content_addressable_storage(&self) -> &BlobAccessConfiguration {
        self.indirect_content_addressable_storage.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_indirect_content_addressable_storage(&mut self) {
        self.indirect_content_addressable_storage.clear();
    }

    pub fn has_indirect_content_addressable_storage(&self) -> bool {
        self.indirect_content_addressable_storage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_indirect_content_addressable_storage(&mut self, v: BlobAccessConfiguration) {
        self.indirect_content_addressable_storage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_indirect_content_addressable_storage(&mut self) -> &mut BlobAccessConfiguration {
        if self.indirect_content_addressable_storage.is_none() {
            self.indirect_content_addressable_storage.set_default();
        }
        self.indirect_content_addressable_storage.as_mut().unwrap()
    }

    // Take field
    pub fn take_indirect_content_addressable_storage(&mut self) -> BlobAccessConfiguration {
        self.indirect_content_addressable_storage.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .cloud.aws.SessionConfiguration aws_session = 2;


    pub fn get_aws_session(&self) -> &super::aws::SessionConfiguration {
        self.aws_session.as_ref().unwrap_or_else(|| super::aws::SessionConfiguration::default_instance())
    }
    pub fn clear_aws_session(&mut self) {
        self.aws_session.clear();
    }

    pub fn has_aws_session(&self) -> bool {
        self.aws_session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aws_session(&mut self, v: super::aws::SessionConfiguration) {
        self.aws_session = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aws_session(&mut self) -> &mut super::aws::SessionConfiguration {
        if self.aws_session.is_none() {
            self.aws_session.set_default();
        }
        self.aws_session.as_mut().unwrap()
    }

    // Take field
    pub fn take_aws_session(&mut self) -> super::aws::SessionConfiguration {
        self.aws_session.take().unwrap_or_else(|| super::aws::SessionConfiguration::new())
    }

    // .http.ClientConfiguration http_client = 3;


    pub fn get_http_client(&self) -> &super::http::ClientConfiguration {
        self.http_client.as_ref().unwrap_or_else(|| super::http::ClientConfiguration::default_instance())
    }
    pub fn clear_http_client(&mut self) {
        self.http_client.clear();
    }

    pub fn has_http_client(&self) -> bool {
        self.http_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_client(&mut self, v: super::http::ClientConfiguration) {
        self.http_client = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_client(&mut self) -> &mut super::http::ClientConfiguration {
        if self.http_client.is_none() {
            self.http_client.set_default();
        }
        self.http_client.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_client(&mut self) -> super::http::ClientConfiguration {
        self.http_client.take().unwrap_or_else(|| super::http::ClientConfiguration::new())
    }
}

impl ::protobuf::Message for ReferenceExpandingBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.indirect_content_addressable_storage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aws_session {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.http_client {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.indirect_content_addressable_storage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aws_session)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http_client)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.indirect_content_addressable_storage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.aws_session.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.http_client.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.indirect_content_addressable_storage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.aws_session.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.http_client.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReferenceExpandingBlobAccessConfiguration {
        ReferenceExpandingBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "indirect_content_addressable_storage",
                    |m: &ReferenceExpandingBlobAccessConfiguration| { &m.indirect_content_addressable_storage },
                    |m: &mut ReferenceExpandingBlobAccessConfiguration| { &mut m.indirect_content_addressable_storage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::aws::SessionConfiguration>>(
                    "aws_session",
                    |m: &ReferenceExpandingBlobAccessConfiguration| { &m.aws_session },
                    |m: &mut ReferenceExpandingBlobAccessConfiguration| { &mut m.aws_session },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::http::ClientConfiguration>>(
                    "http_client",
                    |m: &ReferenceExpandingBlobAccessConfiguration| { &m.http_client },
                    |m: &mut ReferenceExpandingBlobAccessConfiguration| { &mut m.http_client },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReferenceExpandingBlobAccessConfiguration>(
                    "ReferenceExpandingBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReferenceExpandingBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<ReferenceExpandingBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReferenceExpandingBlobAccessConfiguration,
        };
        unsafe {
            instance.get(ReferenceExpandingBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for ReferenceExpandingBlobAccessConfiguration {
    fn clear(&mut self) {
        self.indirect_content_addressable_storage.clear();
        self.aws_session.clear();
        self.http_client.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReferenceExpandingBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReferenceExpandingBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlobReplicatorConfiguration {
    // message oneof groups
    pub mode: ::std::option::Option<BlobReplicatorConfiguration_oneof_mode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlobReplicatorConfiguration {
    fn default() -> &'a BlobReplicatorConfiguration {
        <BlobReplicatorConfiguration as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum BlobReplicatorConfiguration_oneof_mode {
    local(::protobuf::well_known_types::Empty),
    remote(super::grpc::ClientConfiguration),
    queued(QueuedBlobReplicatorConfiguration),
    noop(::protobuf::well_known_types::Empty),
    deduplicating(::std::boxed::Box<BlobReplicatorConfiguration>),
    concurrency_limiting(ConcurrencyLimitingBlobReplicatorConfiguration),
}

impl BlobReplicatorConfiguration {
    pub fn new() -> BlobReplicatorConfiguration {
        ::std::default::Default::default()
    }

    // .google.protobuf.Empty local = 1;


    pub fn get_local(&self) -> &::protobuf::well_known_types::Empty {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::local(ref v)) => v,
            _ => ::protobuf::well_known_types::Empty::default_instance(),
        }
    }
    pub fn clear_local(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_local(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::local(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::local(v))
    }

    // Mutable pointer to the field.
    pub fn mut_local(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::local(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::local(::protobuf::well_known_types::Empty::new()));
        }
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::local(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_local(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_local() {
            match self.mode.take() {
                ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::local(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .grpc.ClientConfiguration remote = 2;


    pub fn get_remote(&self) -> &super::grpc::ClientConfiguration {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::remote(ref v)) => v,
            _ => super::grpc::ClientConfiguration::default_instance(),
        }
    }
    pub fn clear_remote(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_remote(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::remote(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remote(&mut self, v: super::grpc::ClientConfiguration) {
        self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::remote(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remote(&mut self) -> &mut super::grpc::ClientConfiguration {
        if let ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::remote(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::remote(super::grpc::ClientConfiguration::new()));
        }
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::remote(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remote(&mut self) -> super::grpc::ClientConfiguration {
        if self.has_remote() {
            match self.mode.take() {
                ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::remote(v)) => v,
                _ => panic!(),
            }
        } else {
            super::grpc::ClientConfiguration::new()
        }
    }

    // .blobstore.QueuedBlobReplicatorConfiguration queued = 3;


    pub fn get_queued(&self) -> &QueuedBlobReplicatorConfiguration {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::queued(ref v)) => v,
            _ => QueuedBlobReplicatorConfiguration::default_instance(),
        }
    }
    pub fn clear_queued(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_queued(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::queued(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_queued(&mut self, v: QueuedBlobReplicatorConfiguration) {
        self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::queued(v))
    }

    // Mutable pointer to the field.
    pub fn mut_queued(&mut self) -> &mut QueuedBlobReplicatorConfiguration {
        if let ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::queued(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::queued(QueuedBlobReplicatorConfiguration::new()));
        }
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::queued(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_queued(&mut self) -> QueuedBlobReplicatorConfiguration {
        if self.has_queued() {
            match self.mode.take() {
                ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::queued(v)) => v,
                _ => panic!(),
            }
        } else {
            QueuedBlobReplicatorConfiguration::new()
        }
    }

    // .google.protobuf.Empty noop = 4;


    pub fn get_noop(&self) -> &::protobuf::well_known_types::Empty {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::noop(ref v)) => v,
            _ => ::protobuf::well_known_types::Empty::default_instance(),
        }
    }
    pub fn clear_noop(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_noop(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::noop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_noop(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::noop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_noop(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::noop(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::noop(::protobuf::well_known_types::Empty::new()));
        }
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::noop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_noop(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_noop() {
            match self.mode.take() {
                ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::noop(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .blobstore.BlobReplicatorConfiguration deduplicating = 5;


    pub fn get_deduplicating(&self) -> &BlobReplicatorConfiguration {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::deduplicating(ref v)) => v,
            _ => BlobReplicatorConfiguration::default_instance(),
        }
    }
    pub fn clear_deduplicating(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_deduplicating(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::deduplicating(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_deduplicating(&mut self, v: BlobReplicatorConfiguration) {
        self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::deduplicating(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_deduplicating(&mut self) -> &mut BlobReplicatorConfiguration {
        if let ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::deduplicating(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::deduplicating(::std::boxed::Box::new(BlobReplicatorConfiguration::new())));
        }
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::deduplicating(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_deduplicating(&mut self) -> BlobReplicatorConfiguration {
        if self.has_deduplicating() {
            match self.mode.take() {
                ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::deduplicating(v)) => *v,
                _ => panic!(),
            }
        } else {
            BlobReplicatorConfiguration::new()
        }
    }

    // .blobstore.ConcurrencyLimitingBlobReplicatorConfiguration concurrency_limiting = 6;


    pub fn get_concurrency_limiting(&self) -> &ConcurrencyLimitingBlobReplicatorConfiguration {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(ref v)) => v,
            _ => ConcurrencyLimitingBlobReplicatorConfiguration::default_instance(),
        }
    }
    pub fn clear_concurrency_limiting(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_concurrency_limiting(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_concurrency_limiting(&mut self, v: ConcurrencyLimitingBlobReplicatorConfiguration) {
        self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(v))
    }

    // Mutable pointer to the field.
    pub fn mut_concurrency_limiting(&mut self) -> &mut ConcurrencyLimitingBlobReplicatorConfiguration {
        if let ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(ConcurrencyLimitingBlobReplicatorConfiguration::new()));
        }
        match self.mode {
            ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_concurrency_limiting(&mut self) -> ConcurrencyLimitingBlobReplicatorConfiguration {
        if self.has_concurrency_limiting() {
            match self.mode.take() {
                ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(v)) => v,
                _ => panic!(),
            }
        } else {
            ConcurrencyLimitingBlobReplicatorConfiguration::new()
        }
    }
}

impl ::protobuf::Message for BlobReplicatorConfiguration {
    fn is_initialized(&self) -> bool {
        if let Some(BlobReplicatorConfiguration_oneof_mode::local(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobReplicatorConfiguration_oneof_mode::remote(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobReplicatorConfiguration_oneof_mode::queued(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobReplicatorConfiguration_oneof_mode::noop(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobReplicatorConfiguration_oneof_mode::deduplicating(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::local(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::remote(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::queued(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::noop(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::deduplicating(::std::boxed::Box::new(is.read_message()?)));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &BlobReplicatorConfiguration_oneof_mode::local(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobReplicatorConfiguration_oneof_mode::remote(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobReplicatorConfiguration_oneof_mode::queued(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobReplicatorConfiguration_oneof_mode::noop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobReplicatorConfiguration_oneof_mode::deduplicating(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &BlobReplicatorConfiguration_oneof_mode::local(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobReplicatorConfiguration_oneof_mode::remote(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobReplicatorConfiguration_oneof_mode::queued(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobReplicatorConfiguration_oneof_mode::noop(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobReplicatorConfiguration_oneof_mode::deduplicating(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BlobReplicatorConfiguration_oneof_mode::concurrency_limiting(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlobReplicatorConfiguration {
        BlobReplicatorConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                    "local",
                    BlobReplicatorConfiguration::has_local,
                    BlobReplicatorConfiguration::get_local,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::grpc::ClientConfiguration>(
                    "remote",
                    BlobReplicatorConfiguration::has_remote,
                    BlobReplicatorConfiguration::get_remote,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueuedBlobReplicatorConfiguration>(
                    "queued",
                    BlobReplicatorConfiguration::has_queued,
                    BlobReplicatorConfiguration::get_queued,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                    "noop",
                    BlobReplicatorConfiguration::has_noop,
                    BlobReplicatorConfiguration::get_noop,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BlobReplicatorConfiguration>(
                    "deduplicating",
                    BlobReplicatorConfiguration::has_deduplicating,
                    BlobReplicatorConfiguration::get_deduplicating,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConcurrencyLimitingBlobReplicatorConfiguration>(
                    "concurrency_limiting",
                    BlobReplicatorConfiguration::has_concurrency_limiting,
                    BlobReplicatorConfiguration::get_concurrency_limiting,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlobReplicatorConfiguration>(
                    "BlobReplicatorConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlobReplicatorConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<BlobReplicatorConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlobReplicatorConfiguration,
        };
        unsafe {
            instance.get(BlobReplicatorConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for BlobReplicatorConfiguration {
    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlobReplicatorConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlobReplicatorConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueuedBlobReplicatorConfiguration {
    // message fields
    pub base: ::protobuf::SingularPtrField<BlobReplicatorConfiguration>,
    pub existence_cache: ::protobuf::SingularPtrField<super::digest::ExistenceCacheConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueuedBlobReplicatorConfiguration {
    fn default() -> &'a QueuedBlobReplicatorConfiguration {
        <QueuedBlobReplicatorConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl QueuedBlobReplicatorConfiguration {
    pub fn new() -> QueuedBlobReplicatorConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobReplicatorConfiguration base = 1;


    pub fn get_base(&self) -> &BlobReplicatorConfiguration {
        self.base.as_ref().unwrap_or_else(|| BlobReplicatorConfiguration::default_instance())
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: BlobReplicatorConfiguration) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut BlobReplicatorConfiguration {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> BlobReplicatorConfiguration {
        self.base.take().unwrap_or_else(|| BlobReplicatorConfiguration::new())
    }

    // .digest.ExistenceCacheConfiguration existence_cache = 2;


    pub fn get_existence_cache(&self) -> &super::digest::ExistenceCacheConfiguration {
        self.existence_cache.as_ref().unwrap_or_else(|| super::digest::ExistenceCacheConfiguration::default_instance())
    }
    pub fn clear_existence_cache(&mut self) {
        self.existence_cache.clear();
    }

    pub fn has_existence_cache(&self) -> bool {
        self.existence_cache.is_some()
    }

    // Param is passed by value, moved
    pub fn set_existence_cache(&mut self, v: super::digest::ExistenceCacheConfiguration) {
        self.existence_cache = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_existence_cache(&mut self) -> &mut super::digest::ExistenceCacheConfiguration {
        if self.existence_cache.is_none() {
            self.existence_cache.set_default();
        }
        self.existence_cache.as_mut().unwrap()
    }

    // Take field
    pub fn take_existence_cache(&mut self) -> super::digest::ExistenceCacheConfiguration {
        self.existence_cache.take().unwrap_or_else(|| super::digest::ExistenceCacheConfiguration::new())
    }
}

impl ::protobuf::Message for QueuedBlobReplicatorConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.existence_cache {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.existence_cache)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.existence_cache.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.existence_cache.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueuedBlobReplicatorConfiguration {
        QueuedBlobReplicatorConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobReplicatorConfiguration>>(
                    "base",
                    |m: &QueuedBlobReplicatorConfiguration| { &m.base },
                    |m: &mut QueuedBlobReplicatorConfiguration| { &mut m.base },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::digest::ExistenceCacheConfiguration>>(
                    "existence_cache",
                    |m: &QueuedBlobReplicatorConfiguration| { &m.existence_cache },
                    |m: &mut QueuedBlobReplicatorConfiguration| { &mut m.existence_cache },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueuedBlobReplicatorConfiguration>(
                    "QueuedBlobReplicatorConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueuedBlobReplicatorConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<QueuedBlobReplicatorConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueuedBlobReplicatorConfiguration,
        };
        unsafe {
            instance.get(QueuedBlobReplicatorConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for QueuedBlobReplicatorConfiguration {
    fn clear(&mut self) {
        self.base.clear();
        self.existence_cache.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueuedBlobReplicatorConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueuedBlobReplicatorConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcurrencyLimitingBlobReplicatorConfiguration {
    // message fields
    pub base: ::protobuf::SingularPtrField<BlobReplicatorConfiguration>,
    pub maximum_concurrency: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConcurrencyLimitingBlobReplicatorConfiguration {
    fn default() -> &'a ConcurrencyLimitingBlobReplicatorConfiguration {
        <ConcurrencyLimitingBlobReplicatorConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ConcurrencyLimitingBlobReplicatorConfiguration {
    pub fn new() -> ConcurrencyLimitingBlobReplicatorConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobReplicatorConfiguration base = 1;


    pub fn get_base(&self) -> &BlobReplicatorConfiguration {
        self.base.as_ref().unwrap_or_else(|| BlobReplicatorConfiguration::default_instance())
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: BlobReplicatorConfiguration) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut BlobReplicatorConfiguration {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> BlobReplicatorConfiguration {
        self.base.take().unwrap_or_else(|| BlobReplicatorConfiguration::new())
    }

    // int64 maximum_concurrency = 2;


    pub fn get_maximum_concurrency(&self) -> i64 {
        self.maximum_concurrency
    }
    pub fn clear_maximum_concurrency(&mut self) {
        self.maximum_concurrency = 0;
    }

    // Param is passed by value, moved
    pub fn set_maximum_concurrency(&mut self, v: i64) {
        self.maximum_concurrency = v;
    }
}

impl ::protobuf::Message for ConcurrencyLimitingBlobReplicatorConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maximum_concurrency = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.maximum_concurrency != 0 {
            my_size += ::protobuf::rt::value_size(2, self.maximum_concurrency, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.maximum_concurrency != 0 {
            os.write_int64(2, self.maximum_concurrency)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConcurrencyLimitingBlobReplicatorConfiguration {
        ConcurrencyLimitingBlobReplicatorConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobReplicatorConfiguration>>(
                    "base",
                    |m: &ConcurrencyLimitingBlobReplicatorConfiguration| { &m.base },
                    |m: &mut ConcurrencyLimitingBlobReplicatorConfiguration| { &mut m.base },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "maximum_concurrency",
                    |m: &ConcurrencyLimitingBlobReplicatorConfiguration| { &m.maximum_concurrency },
                    |m: &mut ConcurrencyLimitingBlobReplicatorConfiguration| { &mut m.maximum_concurrency },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConcurrencyLimitingBlobReplicatorConfiguration>(
                    "ConcurrencyLimitingBlobReplicatorConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConcurrencyLimitingBlobReplicatorConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<ConcurrencyLimitingBlobReplicatorConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConcurrencyLimitingBlobReplicatorConfiguration,
        };
        unsafe {
            instance.get(ConcurrencyLimitingBlobReplicatorConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for ConcurrencyLimitingBlobReplicatorConfiguration {
    fn clear(&mut self) {
        self.base.clear();
        self.maximum_concurrency = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcurrencyLimitingBlobReplicatorConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcurrencyLimitingBlobReplicatorConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DemultiplexingBlobAccessConfiguration {
    // message fields
    pub instance_name_prefixes: ::std::collections::HashMap<::std::string::String, DemultiplexedBlobAccessConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DemultiplexingBlobAccessConfiguration {
    fn default() -> &'a DemultiplexingBlobAccessConfiguration {
        <DemultiplexingBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DemultiplexingBlobAccessConfiguration {
    pub fn new() -> DemultiplexingBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // repeated .blobstore.DemultiplexingBlobAccessConfiguration.InstanceNamePrefixesEntry instance_name_prefixes = 1;


    pub fn get_instance_name_prefixes(&self) -> &::std::collections::HashMap<::std::string::String, DemultiplexedBlobAccessConfiguration> {
        &self.instance_name_prefixes
    }
    pub fn clear_instance_name_prefixes(&mut self) {
        self.instance_name_prefixes.clear();
    }

    // Param is passed by value, moved
    pub fn set_instance_name_prefixes(&mut self, v: ::std::collections::HashMap<::std::string::String, DemultiplexedBlobAccessConfiguration>) {
        self.instance_name_prefixes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instance_name_prefixes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, DemultiplexedBlobAccessConfiguration> {
        &mut self.instance_name_prefixes
    }

    // Take field
    pub fn take_instance_name_prefixes(&mut self) -> ::std::collections::HashMap<::std::string::String, DemultiplexedBlobAccessConfiguration> {
        ::std::mem::replace(&mut self.instance_name_prefixes, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for DemultiplexingBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<DemultiplexedBlobAccessConfiguration>>(wire_type, is, &mut self.instance_name_prefixes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<DemultiplexedBlobAccessConfiguration>>(1, &self.instance_name_prefixes);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<DemultiplexedBlobAccessConfiguration>>(1, &self.instance_name_prefixes, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DemultiplexingBlobAccessConfiguration {
        DemultiplexingBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<DemultiplexedBlobAccessConfiguration>>(
                    "instance_name_prefixes",
                    |m: &DemultiplexingBlobAccessConfiguration| { &m.instance_name_prefixes },
                    |m: &mut DemultiplexingBlobAccessConfiguration| { &mut m.instance_name_prefixes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DemultiplexingBlobAccessConfiguration>(
                    "DemultiplexingBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DemultiplexingBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<DemultiplexingBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DemultiplexingBlobAccessConfiguration,
        };
        unsafe {
            instance.get(DemultiplexingBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for DemultiplexingBlobAccessConfiguration {
    fn clear(&mut self) {
        self.instance_name_prefixes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DemultiplexingBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DemultiplexingBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DemultiplexedBlobAccessConfiguration {
    // message fields
    pub backend: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub add_instance_name_prefix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DemultiplexedBlobAccessConfiguration {
    fn default() -> &'a DemultiplexedBlobAccessConfiguration {
        <DemultiplexedBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DemultiplexedBlobAccessConfiguration {
    pub fn new() -> DemultiplexedBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration backend = 1;


    pub fn get_backend(&self) -> &BlobAccessConfiguration {
        self.backend.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    pub fn has_backend(&self) -> bool {
        self.backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: BlobAccessConfiguration) {
        self.backend = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut BlobAccessConfiguration {
        if self.backend.is_none() {
            self.backend.set_default();
        }
        self.backend.as_mut().unwrap()
    }

    // Take field
    pub fn take_backend(&mut self) -> BlobAccessConfiguration {
        self.backend.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // string add_instance_name_prefix = 2;


    pub fn get_add_instance_name_prefix(&self) -> &str {
        &self.add_instance_name_prefix
    }
    pub fn clear_add_instance_name_prefix(&mut self) {
        self.add_instance_name_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_add_instance_name_prefix(&mut self, v: ::std::string::String) {
        self.add_instance_name_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_add_instance_name_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.add_instance_name_prefix
    }

    // Take field
    pub fn take_add_instance_name_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.add_instance_name_prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DemultiplexedBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.backend {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backend)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.add_instance_name_prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.add_instance_name_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.add_instance_name_prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backend.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.add_instance_name_prefix.is_empty() {
            os.write_string(2, &self.add_instance_name_prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DemultiplexedBlobAccessConfiguration {
        DemultiplexedBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "backend",
                    |m: &DemultiplexedBlobAccessConfiguration| { &m.backend },
                    |m: &mut DemultiplexedBlobAccessConfiguration| { &mut m.backend },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "add_instance_name_prefix",
                    |m: &DemultiplexedBlobAccessConfiguration| { &m.add_instance_name_prefix },
                    |m: &mut DemultiplexedBlobAccessConfiguration| { &mut m.add_instance_name_prefix },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DemultiplexedBlobAccessConfiguration>(
                    "DemultiplexedBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DemultiplexedBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<DemultiplexedBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DemultiplexedBlobAccessConfiguration,
        };
        unsafe {
            instance.get(DemultiplexedBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for DemultiplexedBlobAccessConfiguration {
    fn clear(&mut self) {
        self.backend.clear();
        self.add_instance_name_prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DemultiplexedBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DemultiplexedBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionResultExpiringBlobAccessConfiguration {
    // message fields
    pub backend: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub minimum_validity: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub maximum_validity_jitter: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionResultExpiringBlobAccessConfiguration {
    fn default() -> &'a ActionResultExpiringBlobAccessConfiguration {
        <ActionResultExpiringBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ActionResultExpiringBlobAccessConfiguration {
    pub fn new() -> ActionResultExpiringBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration backend = 1;


    pub fn get_backend(&self) -> &BlobAccessConfiguration {
        self.backend.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    pub fn has_backend(&self) -> bool {
        self.backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: BlobAccessConfiguration) {
        self.backend = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut BlobAccessConfiguration {
        if self.backend.is_none() {
            self.backend.set_default();
        }
        self.backend.as_mut().unwrap()
    }

    // Take field
    pub fn take_backend(&mut self) -> BlobAccessConfiguration {
        self.backend.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .google.protobuf.Duration minimum_validity = 2;


    pub fn get_minimum_validity(&self) -> &::protobuf::well_known_types::Duration {
        self.minimum_validity.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_minimum_validity(&mut self) {
        self.minimum_validity.clear();
    }

    pub fn has_minimum_validity(&self) -> bool {
        self.minimum_validity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum_validity(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.minimum_validity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimum_validity(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.minimum_validity.is_none() {
            self.minimum_validity.set_default();
        }
        self.minimum_validity.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimum_validity(&mut self) -> ::protobuf::well_known_types::Duration {
        self.minimum_validity.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration maximum_validity_jitter = 3;


    pub fn get_maximum_validity_jitter(&self) -> &::protobuf::well_known_types::Duration {
        self.maximum_validity_jitter.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_maximum_validity_jitter(&mut self) {
        self.maximum_validity_jitter.clear();
    }

    pub fn has_maximum_validity_jitter(&self) -> bool {
        self.maximum_validity_jitter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_validity_jitter(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.maximum_validity_jitter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maximum_validity_jitter(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.maximum_validity_jitter.is_none() {
            self.maximum_validity_jitter.set_default();
        }
        self.maximum_validity_jitter.as_mut().unwrap()
    }

    // Take field
    pub fn take_maximum_validity_jitter(&mut self) -> ::protobuf::well_known_types::Duration {
        self.maximum_validity_jitter.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for ActionResultExpiringBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.backend {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.minimum_validity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.maximum_validity_jitter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backend)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.minimum_validity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.maximum_validity_jitter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.minimum_validity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.maximum_validity_jitter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backend.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.minimum_validity.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.maximum_validity_jitter.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionResultExpiringBlobAccessConfiguration {
        ActionResultExpiringBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "backend",
                    |m: &ActionResultExpiringBlobAccessConfiguration| { &m.backend },
                    |m: &mut ActionResultExpiringBlobAccessConfiguration| { &mut m.backend },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "minimum_validity",
                    |m: &ActionResultExpiringBlobAccessConfiguration| { &m.minimum_validity },
                    |m: &mut ActionResultExpiringBlobAccessConfiguration| { &mut m.minimum_validity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "maximum_validity_jitter",
                    |m: &ActionResultExpiringBlobAccessConfiguration| { &m.maximum_validity_jitter },
                    |m: &mut ActionResultExpiringBlobAccessConfiguration| { &mut m.maximum_validity_jitter },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionResultExpiringBlobAccessConfiguration>(
                    "ActionResultExpiringBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionResultExpiringBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<ActionResultExpiringBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionResultExpiringBlobAccessConfiguration,
        };
        unsafe {
            instance.get(ActionResultExpiringBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for ActionResultExpiringBlobAccessConfiguration {
    fn clear(&mut self) {
        self.backend.clear();
        self.minimum_validity.clear();
        self.maximum_validity_jitter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionResultExpiringBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionResultExpiringBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadCanaryingBlobAccessConfiguration {
    // message fields
    pub source: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub replica: ::protobuf::SingularPtrField<BlobAccessConfiguration>,
    pub maximum_cache_size: i32,
    pub maximum_cache_duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadCanaryingBlobAccessConfiguration {
    fn default() -> &'a ReadCanaryingBlobAccessConfiguration {
        <ReadCanaryingBlobAccessConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ReadCanaryingBlobAccessConfiguration {
    pub fn new() -> ReadCanaryingBlobAccessConfiguration {
        ::std::default::Default::default()
    }

    // .blobstore.BlobAccessConfiguration source = 1;


    pub fn get_source(&self) -> &BlobAccessConfiguration {
        self.source.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: BlobAccessConfiguration) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut BlobAccessConfiguration {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> BlobAccessConfiguration {
        self.source.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // .blobstore.BlobAccessConfiguration replica = 2;


    pub fn get_replica(&self) -> &BlobAccessConfiguration {
        self.replica.as_ref().unwrap_or_else(|| BlobAccessConfiguration::default_instance())
    }
    pub fn clear_replica(&mut self) {
        self.replica.clear();
    }

    pub fn has_replica(&self) -> bool {
        self.replica.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replica(&mut self, v: BlobAccessConfiguration) {
        self.replica = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replica(&mut self) -> &mut BlobAccessConfiguration {
        if self.replica.is_none() {
            self.replica.set_default();
        }
        self.replica.as_mut().unwrap()
    }

    // Take field
    pub fn take_replica(&mut self) -> BlobAccessConfiguration {
        self.replica.take().unwrap_or_else(|| BlobAccessConfiguration::new())
    }

    // int32 maximum_cache_size = 3;


    pub fn get_maximum_cache_size(&self) -> i32 {
        self.maximum_cache_size
    }
    pub fn clear_maximum_cache_size(&mut self) {
        self.maximum_cache_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_maximum_cache_size(&mut self, v: i32) {
        self.maximum_cache_size = v;
    }

    // .google.protobuf.Duration maximum_cache_duration = 4;


    pub fn get_maximum_cache_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.maximum_cache_duration.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_maximum_cache_duration(&mut self) {
        self.maximum_cache_duration.clear();
    }

    pub fn has_maximum_cache_duration(&self) -> bool {
        self.maximum_cache_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_cache_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.maximum_cache_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maximum_cache_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.maximum_cache_duration.is_none() {
            self.maximum_cache_duration.set_default();
        }
        self.maximum_cache_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_maximum_cache_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.maximum_cache_duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for ReadCanaryingBlobAccessConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.replica {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.maximum_cache_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.replica)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maximum_cache_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.maximum_cache_duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.replica.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.maximum_cache_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.maximum_cache_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.maximum_cache_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.replica.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.maximum_cache_size != 0 {
            os.write_int32(3, self.maximum_cache_size)?;
        }
        if let Some(ref v) = self.maximum_cache_duration.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadCanaryingBlobAccessConfiguration {
        ReadCanaryingBlobAccessConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "source",
                    |m: &ReadCanaryingBlobAccessConfiguration| { &m.source },
                    |m: &mut ReadCanaryingBlobAccessConfiguration| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobAccessConfiguration>>(
                    "replica",
                    |m: &ReadCanaryingBlobAccessConfiguration| { &m.replica },
                    |m: &mut ReadCanaryingBlobAccessConfiguration| { &mut m.replica },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maximum_cache_size",
                    |m: &ReadCanaryingBlobAccessConfiguration| { &m.maximum_cache_size },
                    |m: &mut ReadCanaryingBlobAccessConfiguration| { &mut m.maximum_cache_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "maximum_cache_duration",
                    |m: &ReadCanaryingBlobAccessConfiguration| { &m.maximum_cache_duration },
                    |m: &mut ReadCanaryingBlobAccessConfiguration| { &mut m.maximum_cache_duration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadCanaryingBlobAccessConfiguration>(
                    "ReadCanaryingBlobAccessConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadCanaryingBlobAccessConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<ReadCanaryingBlobAccessConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadCanaryingBlobAccessConfiguration,
        };
        unsafe {
            instance.get(ReadCanaryingBlobAccessConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for ReadCanaryingBlobAccessConfiguration {
    fn clear(&mut self) {
        self.source.clear();
        self.replica.clear();
        self.maximum_cache_size = 0;
        self.maximum_cache_duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadCanaryingBlobAccessConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadCanaryingBlobAccessConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-proto/configuration/blobstore/blobstore.proto\x12\tblobstore\x1a\x1eg\
    oogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a1pro\
    to/configuration/blockdevice/blockdevice.proto\x1a'proto/configuration/c\
    loud/aws/aws.proto\x1a'proto/configuration/digest/digest.proto\x1a#proto\
    /configuration/grpc/grpc.proto\x1a#proto/configuration/http/http.proto\
    \x1a!proto/configuration/tls/tls.proto\x1aTproto/configuration/blobstore\
    /googleapis-common-protos-1_3_1/google/rpc/status.proto\"\xc3\x01\n\x16B\
    lobstoreConfiguration\x12b\n\x1bcontent_addressable_storage\x18\x01\x20\
    \x01(\x0b2\".blobstore.BlobAccessConfigurationR\x19contentAddressableSto\
    rage\x12E\n\x0caction_cache\x18\x02\x20\x01(\x0b2\".blobstore.BlobAccess\
    ConfigurationR\x0bactionCache\"\xa8\x0b\n\x17BlobAccessConfiguration\x12\
    ?\n\x05redis\x18\x02\x20\x01(\x0b2'.blobstore.RedisBlobAccessConfigurati\
    onH\0R\x05redis\x12<\n\x04http\x18\x03\x20\x01(\x0b2&.blobstore.HTTPBlob\
    AccessConfigurationH\0R\x04http\x12R\n\x0cread_caching\x18\x04\x20\x01(\
    \x0b2-.blobstore.ReadCachingBlobAccessConfigurationH\0R\x0breadCaching\
    \x12g\n\x13size_distinguishing\x18\x05\x20\x01(\x0b24.blobstore.SizeDist\
    inguishingBlobAccessConfigurationH\0R\x12sizeDistinguishing\x12/\n\x04gr\
    pc\x18\x07\x20\x01(\x0b2\x19.grpc.ClientConfigurationH\0R\x04grpc\x12*\n\
    \x05error\x18\x08\x20\x01(\x0b2\x12.google.rpc.StatusH\0R\x05error\x12H\
    \n\x08sharding\x18\t\x20\x01(\x0b2*.blobstore.ShardingBlobAccessConfigur\
    ationH\0R\x08sharding\x12H\n\x08mirrored\x18\x0e\x20\x01(\x0b2*.blobstor\
    e.MirroredBlobAccessConfigurationH\0R\x08mirrored\x12?\n\x05local\x18\
    \x0f\x20\x01(\x0b2'.blobstore.LocalBlobAccessConfigurationH\0R\x05local\
    \x12a\n\x11existence_caching\x18\x10\x20\x01(\x0b22.blobstore.ExistenceC\
    achingBlobAccessConfigurationH\0R\x10existenceCaching\x12Y\n\x15complete\
    ness_checking\x18\x11\x20\x01(\x0b2\".blobstore.BlobAccessConfigurationH\
    \0R\x14completenessChecking\x12U\n\rread_fallback\x18\x12\x20\x01(\x0b2.\
    .blobstore.ReadFallbackBlobAccessConfigurationH\0R\x0creadFallback\x12g\
    \n\x13reference_expanding\x18\x13\x20\x01(\x0b24.blobstore.ReferenceExpa\
    ndingBlobAccessConfigurationH\0R\x12referenceExpanding\x12Z\n\x0edemulti\
    plexing\x18\x14\x20\x01(\x0b20.blobstore.DemultiplexingBlobAccessConfigu\
    rationH\0R\x0edemultiplexing\x12d\n\x1bhierarchical_instance_names\x18\
    \x15\x20\x01(\x0b2\".blobstore.BlobAccessConfigurationH\0R\x19hierarchic\
    alInstanceNames\x12n\n\x16action_result_expiring\x18\x16\x20\x01(\x0b26.\
    blobstore.ActionResultExpiringBlobAccessConfigurationH\0R\x14actionResul\
    tExpiring\x12X\n\x0eread_canarying\x18\x17\x20\x01(\x0b2/.blobstore.Read\
    CanaryingBlobAccessConfigurationH\0R\rreadCanaryingB\t\n\x07backendJ\x04\
    \x08\x06\x10\x07J\x04\x08\n\x10\x0b\"\xdc\x01\n\"ReadCachingBlobAccessCo\
    nfiguration\x126\n\x04slow\x18\x01\x20\x01(\x0b2\".blobstore.BlobAccessC\
    onfigurationR\x04slow\x126\n\x04fast\x18\x02\x20\x01(\x0b2\".blobstore.B\
    lobAccessConfigurationR\x04fast\x12F\n\nreplicator\x18\x03\x20\x01(\x0b2\
    &.blobstore.BlobReplicatorConfigurationR\nreplicator\"\x8c\x02\n%Cluster\
    edRedisBlobAccessConfiguration\x12\x1c\n\tendpoints\x18\x01\x20\x03(\tR\
    \tendpoints\x12'\n\x0fmaximum_retries\x18\x02\x20\x01(\rR\x0emaximumRetr\
    ies\x12M\n\x15minimum_retry_backoff\x18\x03\x20\x01(\x0b2\x19.google.pro\
    tobuf.DurationR\x13minimumRetryBackoff\x12M\n\x15maximum_retry_backoff\
    \x18\x04\x20\x01(\x0b2\x19.google.protobuf.DurationR\x13maximumRetryBack\
    off\"l\n\"SingleRedisBlobAccessConfiguration\x12\x1a\n\x08endpoint\x18\
    \x01\x20\x01(\tR\x08endpoint\x12\x0e\n\x02db\x18\x02\x20\x01(\x05R\x02db\
    \x12\x1a\n\x08password\x18\x03\x20\x01(\tR\x08password\"\xa8\x04\n\x1cRe\
    disBlobAccessConfiguration\x12P\n\tclustered\x18\x01\x20\x01(\x0b20.blob\
    store.ClusteredRedisBlobAccessConfigurationH\0R\tclustered\x12G\n\x06sin\
    gle\x18\x02\x20\x01(\x0b2-.blobstore.SingleRedisBlobAccessConfigurationH\
    \0R\x06single\x12*\n\x03tls\x18\x04\x20\x01(\x0b2\x18.tls.ClientConfigur\
    ationR\x03tls\x12+\n\x11replication_count\x18\x08\x20\x01(\x03R\x10repli\
    cationCount\x12J\n\x13replication_timeout\x18\t\x20\x01(\x0b2\x19.google\
    .protobuf.DurationR\x12replicationTimeout\x12<\n\x0cdial_timeout\x18\n\
    \x20\x01(\x0b2\x19.google.protobuf.DurationR\x0bdialTimeout\x12<\n\x0cre\
    ad_timeout\x18\x0b\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0breadTi\
    meout\x12>\n\rwrite_timeout\x18\x0c\x20\x01(\x0b2\x19.google.protobuf.Du\
    rationR\x0cwriteTimeoutB\x06\n\x04modeJ\x04\x08\x07\x10\x08\"j\n\x1bHTTP\
    BlobAccessConfiguration\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07addr\
    ess\x121\n\x06client\x18\x02\x20\x01(\x0b2\x19.http.ClientConfigurationR\
    \x06client\"\xfb\x01\n\x1fShardingBlobAccessConfiguration\x12/\n\x13hash\
    _initialization\x18\x01\x20\x01(\x04R\x12hashInitialization\x12H\n\x06sh\
    ards\x18\x02\x20\x03(\x0b20.blobstore.ShardingBlobAccessConfiguration.Sh\
    ardR\x06shards\x1a]\n\x05Shard\x12<\n\x07backend\x18\x01\x20\x01(\x0b2\"\
    .blobstore.BlobAccessConfigurationR\x07backend\x12\x16\n\x06weight\x18\
    \x02\x20\x01(\rR\x06weight\"\xcb\x01\n)SizeDistinguishingBlobAccessConfi\
    guration\x128\n\x05small\x18\x01\x20\x01(\x0b2\".blobstore.BlobAccessCon\
    figurationR\x05small\x128\n\x05large\x18\x02\x20\x01(\x0b2\".blobstore.B\
    lobAccessConfigurationR\x05large\x12*\n\x11cutoff_size_bytes\x18\x03\x20\
    \x01(\x03R\x0fcutoffSizeBytes\"\xc9\x02\n\x1fMirroredBlobAccessConfigura\
    tion\x12?\n\tbackend_a\x18\x01\x20\x01(\x0b2\".blobstore.BlobAccessConfi\
    gurationR\x08backendA\x12?\n\tbackend_b\x18\x02\x20\x01(\x0b2\".blobstor\
    e.BlobAccessConfigurationR\x08backendB\x12Q\n\x11replicator_a_to_b\x18\
    \x03\x20\x01(\x0b2&.blobstore.BlobReplicatorConfigurationR\x0ereplicator\
    AToB\x12Q\n\x11replicator_b_to_a\x18\x04\x20\x01(\x0b2&.blobstore.BlobRe\
    plicatorConfigurationR\x0ereplicatorBToA\"\x8b\x0b\n\x1cLocalBlobAccessC\
    onfiguration\x12|\n\x1akey_location_map_in_memory\x18\x0b\x20\x01(\x0b2>\
    .blobstore.LocalBlobAccessConfiguration.KeyLocationMapInMemoryH\0R\x16ke\
    yLocationMapInMemory\x12c\n\x20key_location_map_on_block_device\x18\x0c\
    \x20\x01(\x0b2\x1a.blockdevice.ConfigurationH\0R\x1bkeyLocationMapOnBloc\
    kDevice\x12O\n%key_location_map_maximum_get_attempts\x18\x02\x20\x01(\rR\
    \x20keyLocationMapMaximumGetAttempts\x12O\n%key_location_map_maximum_put\
    _attempts\x18\x03\x20\x01(\x03R\x20keyLocationMapMaximumPutAttempts\x12\
    \x1d\n\nold_blocks\x18\x05\x20\x01(\x05R\toldBlocks\x12%\n\x0ecurrent_bl\
    ocks\x18\x06\x20\x01(\x05R\rcurrentBlocks\x12\x1d\n\nnew_blocks\x18\x07\
    \x20\x01(\x05R\tnewBlocks\x12b\n\x10blocks_in_memory\x18\t\x20\x01(\x0b2\
    6.blobstore.LocalBlobAccessConfiguration.BlocksInMemoryH\x01R\x0eblocksI\
    nMemory\x12r\n\x16blocks_on_block_device\x18\n\x20\x01(\x0b2;.blobstore.\
    LocalBlobAccessConfiguration.BlocksOnBlockDeviceH\x01R\x13blocksOnBlockD\
    evice\x12R\n\npersistent\x18\r\x20\x01(\x0b22.blobstore.LocalBlobAccessC\
    onfiguration.PersistentR\npersistent\x12>\n\x1bhierarchical_instance_nam\
    es\x18\x0e\x20\x01(\x08R\x19hierarchicalInstanceNames\x1a2\n\x16KeyLocat\
    ionMapInMemory\x12\x18\n\x07entries\x18\x01\x20\x01(\x03R\x07entries\x1a\
    :\n\x0eBlocksInMemory\x12(\n\x10block_size_bytes\x18\x01\x20\x01(\x03R\
    \x0eblockSizeBytes\x1a\xd8\x01\n\x13BlocksOnBlockDevice\x122\n\x06source\
    \x18\x01\x20\x01(\x0b2\x1a.blockdevice.ConfigurationR\x06source\x12!\n\
    \x0cspare_blocks\x18\x02\x20\x01(\x05R\x0bspareBlocks\x12j\n\x1fdata_int\
    egrity_validation_cache\x18\x03\x20\x01(\x0b2#.digest.ExistenceCacheConf\
    igurationR\x1cdataIntegrityValidationCache\x1a\x8f\x01\n\nPersistent\x12\
    0\n\x14state_directory_path\x18\x01\x20\x01(\tR\x12stateDirectoryPath\
    \x12O\n\x16minimum_epoch_interval\x18\x02\x20\x01(\x0b2\x19.google.proto\
    buf.DurationR\x14minimumEpochIntervalB\x1a\n\x18key_location_map_backend\
    B\x10\n\x0eblocks_backendJ\x04\x08\x01\x10\x02J\x04\x08\x08\x10\t\"\xb5\
    \x01\n'ExistenceCachingBlobAccessConfiguration\x12<\n\x07backend\x18\x01\
    \x20\x01(\x0b2\".blobstore.BlobAccessConfigurationR\x07backend\x12L\n\
    \x0fexistence_cache\x18\x02\x20\x01(\x0b2#.digest.ExistenceCacheConfigur\
    ationR\x0eexistenceCache\"\xed\x01\n#ReadFallbackBlobAccessConfiguration\
    \x12<\n\x07primary\x18\x01\x20\x01(\x0b2\".blobstore.BlobAccessConfigura\
    tionR\x07primary\x12@\n\tsecondary\x18\x02\x20\x01(\x0b2\".blobstore.Blo\
    bAccessConfigurationR\tsecondary\x12F\n\nreplicator\x18\x03\x20\x01(\x0b\
    2&.blobstore.BlobReplicatorConfigurationR\nreplicator\"\x9e\x02\n)Refere\
    nceExpandingBlobAccessConfiguration\x12s\n$indirect_content_addressable_\
    storage\x18\x01\x20\x01(\x0b2\".blobstore.BlobAccessConfigurationR!indir\
    ectContentAddressableStorage\x12@\n\x0baws_session\x18\x02\x20\x01(\x0b2\
    \x1f.cloud.aws.SessionConfigurationR\nawsSession\x12:\n\x0bhttp_client\
    \x18\x03\x20\x01(\x0b2\x19.http.ClientConfigurationR\nhttpClient\"\xc0\
    \x03\n\x1bBlobReplicatorConfiguration\x12.\n\x05local\x18\x01\x20\x01(\
    \x0b2\x16.google.protobuf.EmptyH\0R\x05local\x123\n\x06remote\x18\x02\
    \x20\x01(\x0b2\x19.grpc.ClientConfigurationH\0R\x06remote\x12F\n\x06queu\
    ed\x18\x03\x20\x01(\x0b2,.blobstore.QueuedBlobReplicatorConfigurationH\0\
    R\x06queued\x12,\n\x04noop\x18\x04\x20\x01(\x0b2\x16.google.protobuf.Emp\
    tyH\0R\x04noop\x12N\n\rdeduplicating\x18\x05\x20\x01(\x0b2&.blobstore.Bl\
    obReplicatorConfigurationH\0R\rdeduplicating\x12n\n\x14concurrency_limit\
    ing\x18\x06\x20\x01(\x0b29.blobstore.ConcurrencyLimitingBlobReplicatorCo\
    nfigurationH\0R\x13concurrencyLimitingB\x06\n\x04mode\"\xad\x01\n!Queued\
    BlobReplicatorConfiguration\x12:\n\x04base\x18\x01\x20\x01(\x0b2&.blobst\
    ore.BlobReplicatorConfigurationR\x04base\x12L\n\x0fexistence_cache\x18\
    \x02\x20\x01(\x0b2#.digest.ExistenceCacheConfigurationR\x0eexistenceCach\
    e\"\x9d\x01\n.ConcurrencyLimitingBlobReplicatorConfiguration\x12:\n\x04b\
    ase\x18\x01\x20\x01(\x0b2&.blobstore.BlobReplicatorConfigurationR\x04bas\
    e\x12/\n\x13maximum_concurrency\x18\x02\x20\x01(\x03R\x12maximumConcurre\
    ncy\"\xa4\x02\n%DemultiplexingBlobAccessConfiguration\x12\x80\x01\n\x16i\
    nstance_name_prefixes\x18\x01\x20\x03(\x0b2J.blobstore.DemultiplexingBlo\
    bAccessConfiguration.InstanceNamePrefixesEntryR\x14instanceNamePrefixes\
    \x1ax\n\x19InstanceNamePrefixesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\t\
    R\x03key\x12E\n\x05value\x18\x02\x20\x01(\x0b2/.blobstore.DemultiplexedB\
    lobAccessConfigurationR\x05value:\x028\x01\"\x9d\x01\n$DemultiplexedBlob\
    AccessConfiguration\x12<\n\x07backend\x18\x01\x20\x01(\x0b2\".blobstore.\
    BlobAccessConfigurationR\x07backend\x127\n\x18add_instance_name_prefix\
    \x18\x02\x20\x01(\tR\x15addInstanceNamePrefix\"\x84\x02\n+ActionResultEx\
    piringBlobAccessConfiguration\x12<\n\x07backend\x18\x01\x20\x01(\x0b2\".\
    blobstore.BlobAccessConfigurationR\x07backend\x12D\n\x10minimum_validity\
    \x18\x02\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0fminimumValidity\
    \x12Q\n\x17maximum_validity_jitter\x18\x03\x20\x01(\x0b2\x19.google.prot\
    obuf.DurationR\x15maximumValidityJitter\"\x9f\x02\n$ReadCanaryingBlobAcc\
    essConfiguration\x12:\n\x06source\x18\x01\x20\x01(\x0b2\".blobstore.Blob\
    AccessConfigurationR\x06source\x12<\n\x07replica\x18\x02\x20\x01(\x0b2\"\
    .blobstore.BlobAccessConfigurationR\x07replica\x12,\n\x12maximum_cache_s\
    ize\x18\x03\x20\x01(\x05R\x10maximumCacheSize\x12O\n\x16maximum_cache_du\
    ration\x18\x04\x20\x01(\x0b2\x19.google.protobuf.DurationR\x14maximumCac\
    heDurationb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
