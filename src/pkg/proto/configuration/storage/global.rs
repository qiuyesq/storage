// This file is generated by rust-protobuf 2.8.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `proto/configuration/global/global.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_2;

#[derive(PartialEq,Clone,Default)]
pub struct PrometheusPushgatewayConfiguration {
    // message fields
    pub url: ::std::string::String,
    pub job: ::std::string::String,
    pub grouping: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub push_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub http_client: ::protobuf::SingularPtrField<super::http::ClientConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrometheusPushgatewayConfiguration {
    fn default() -> &'a PrometheusPushgatewayConfiguration {
        <PrometheusPushgatewayConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl PrometheusPushgatewayConfiguration {
    pub fn new() -> PrometheusPushgatewayConfiguration {
        ::std::default::Default::default()
    }

    // string url = 1;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // string job = 2;


    pub fn get_job(&self) -> &str {
        &self.job
    }
    pub fn clear_job(&mut self) {
        self.job.clear();
    }

    // Param is passed by value, moved
    pub fn set_job(&mut self, v: ::std::string::String) {
        self.job = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job(&mut self) -> &mut ::std::string::String {
        &mut self.job
    }

    // Take field
    pub fn take_job(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.job, ::std::string::String::new())
    }

    // repeated .global.PrometheusPushgatewayConfiguration.GroupingEntry grouping = 4;


    pub fn get_grouping(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.grouping
    }
    pub fn clear_grouping(&mut self) {
        self.grouping.clear();
    }

    // Param is passed by value, moved
    pub fn set_grouping(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.grouping = v;
    }

    // Mutable pointer to the field.
    pub fn mut_grouping(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.grouping
    }

    // Take field
    pub fn take_grouping(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.grouping, ::std::collections::HashMap::new())
    }

    // .google.protobuf.Duration push_interval = 5;


    pub fn get_push_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.push_interval.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_push_interval(&mut self) {
        self.push_interval.clear();
    }

    pub fn has_push_interval(&self) -> bool {
        self.push_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.push_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_push_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.push_interval.is_none() {
            self.push_interval.set_default();
        }
        self.push_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_push_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.push_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .http.ClientConfiguration http_client = 6;


    pub fn get_http_client(&self) -> &super::http::ClientConfiguration {
        self.http_client.as_ref().unwrap_or_else(|| super::http::ClientConfiguration::default_instance())
    }
    pub fn clear_http_client(&mut self) {
        self.http_client.clear();
    }

    pub fn has_http_client(&self) -> bool {
        self.http_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_client(&mut self, v: super::http::ClientConfiguration) {
        self.http_client = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_client(&mut self) -> &mut super::http::ClientConfiguration {
        if self.http_client.is_none() {
            self.http_client.set_default();
        }
        self.http_client.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_client(&mut self) -> super::http::ClientConfiguration {
        self.http_client.take().unwrap_or_else(|| super::http::ClientConfiguration::new())
    }
}

impl ::protobuf::Message for PrometheusPushgatewayConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.push_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.http_client {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.job)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.grouping)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.push_interval)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http_client)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if !self.job.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.job);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.grouping);
        if let Some(ref v) = self.push_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.http_client.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if !self.job.is_empty() {
            os.write_string(2, &self.job)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.grouping, os)?;
        if let Some(ref v) = self.push_interval.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.http_client.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrometheusPushgatewayConfiguration {
        PrometheusPushgatewayConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &PrometheusPushgatewayConfiguration| { &m.url },
                    |m: &mut PrometheusPushgatewayConfiguration| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "job",
                    |m: &PrometheusPushgatewayConfiguration| { &m.job },
                    |m: &mut PrometheusPushgatewayConfiguration| { &mut m.job },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "grouping",
                    |m: &PrometheusPushgatewayConfiguration| { &m.grouping },
                    |m: &mut PrometheusPushgatewayConfiguration| { &mut m.grouping },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "push_interval",
                    |m: &PrometheusPushgatewayConfiguration| { &m.push_interval },
                    |m: &mut PrometheusPushgatewayConfiguration| { &mut m.push_interval },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::http::ClientConfiguration>>(
                    "http_client",
                    |m: &PrometheusPushgatewayConfiguration| { &m.http_client },
                    |m: &mut PrometheusPushgatewayConfiguration| { &mut m.http_client },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PrometheusPushgatewayConfiguration>(
                    "PrometheusPushgatewayConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PrometheusPushgatewayConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<PrometheusPushgatewayConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PrometheusPushgatewayConfiguration,
        };
        unsafe {
            instance.get(PrometheusPushgatewayConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for PrometheusPushgatewayConfiguration {
    fn clear(&mut self) {
        self.url.clear();
        self.job.clear();
        self.grouping.clear();
        self.push_interval.clear();
        self.http_client.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrometheusPushgatewayConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrometheusPushgatewayConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration {
    // message fields
    pub backends: ::protobuf::RepeatedField<TracingConfiguration_Backend>,
    pub resource_attributes: ::std::collections::HashMap<::std::string::String, TracingConfiguration_ResourceAttributeValue>,
    pub sampler: ::protobuf::SingularPtrField<TracingConfiguration_Sampler>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration {
    fn default() -> &'a TracingConfiguration {
        <TracingConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl TracingConfiguration {
    pub fn new() -> TracingConfiguration {
        ::std::default::Default::default()
    }

    // repeated .global.TracingConfiguration.Backend backends = 1;


    pub fn get_backends(&self) -> &[TracingConfiguration_Backend] {
        &self.backends
    }
    pub fn clear_backends(&mut self) {
        self.backends.clear();
    }

    // Param is passed by value, moved
    pub fn set_backends(&mut self, v: ::protobuf::RepeatedField<TracingConfiguration_Backend>) {
        self.backends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_backends(&mut self) -> &mut ::protobuf::RepeatedField<TracingConfiguration_Backend> {
        &mut self.backends
    }

    // Take field
    pub fn take_backends(&mut self) -> ::protobuf::RepeatedField<TracingConfiguration_Backend> {
        ::std::mem::replace(&mut self.backends, ::protobuf::RepeatedField::new())
    }

    // repeated .global.TracingConfiguration.ResourceAttributesEntry resource_attributes = 2;


    pub fn get_resource_attributes(&self) -> &::std::collections::HashMap<::std::string::String, TracingConfiguration_ResourceAttributeValue> {
        &self.resource_attributes
    }
    pub fn clear_resource_attributes(&mut self) {
        self.resource_attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_attributes(&mut self, v: ::std::collections::HashMap<::std::string::String, TracingConfiguration_ResourceAttributeValue>) {
        self.resource_attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_attributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, TracingConfiguration_ResourceAttributeValue> {
        &mut self.resource_attributes
    }

    // Take field
    pub fn take_resource_attributes(&mut self) -> ::std::collections::HashMap<::std::string::String, TracingConfiguration_ResourceAttributeValue> {
        ::std::mem::replace(&mut self.resource_attributes, ::std::collections::HashMap::new())
    }

    // .global.TracingConfiguration.Sampler sampler = 3;


    pub fn get_sampler(&self) -> &TracingConfiguration_Sampler {
        self.sampler.as_ref().unwrap_or_else(|| TracingConfiguration_Sampler::default_instance())
    }
    pub fn clear_sampler(&mut self) {
        self.sampler.clear();
    }

    pub fn has_sampler(&self) -> bool {
        self.sampler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sampler(&mut self, v: TracingConfiguration_Sampler) {
        self.sampler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sampler(&mut self) -> &mut TracingConfiguration_Sampler {
        if self.sampler.is_none() {
            self.sampler.set_default();
        }
        self.sampler.as_mut().unwrap()
    }

    // Take field
    pub fn take_sampler(&mut self) -> TracingConfiguration_Sampler {
        self.sampler.take().unwrap_or_else(|| TracingConfiguration_Sampler::new())
    }
}

impl ::protobuf::Message for TracingConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.backends {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sampler {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.backends)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_ResourceAttributeValue>>(wire_type, is, &mut self.resource_attributes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sampler)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.backends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_ResourceAttributeValue>>(2, &self.resource_attributes);
        if let Some(ref v) = self.sampler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.backends {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_ResourceAttributeValue>>(2, &self.resource_attributes, os)?;
        if let Some(ref v) = self.sampler.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration {
        TracingConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_Backend>>(
                    "backends",
                    |m: &TracingConfiguration| { &m.backends },
                    |m: &mut TracingConfiguration| { &mut m.backends },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_ResourceAttributeValue>>(
                    "resource_attributes",
                    |m: &TracingConfiguration| { &m.resource_attributes },
                    |m: &mut TracingConfiguration| { &mut m.resource_attributes },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_Sampler>>(
                    "sampler",
                    |m: &TracingConfiguration| { &m.sampler },
                    |m: &mut TracingConfiguration| { &mut m.sampler },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration>(
                    "TracingConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration,
        };
        unsafe {
            instance.get(TracingConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration {
    fn clear(&mut self) {
        self.backends.clear();
        self.resource_attributes.clear();
        self.sampler.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_Backend {
    // message oneof groups
    pub span_exporter: ::std::option::Option<TracingConfiguration_Backend_oneof_span_exporter>,
    pub span_processor: ::std::option::Option<TracingConfiguration_Backend_oneof_span_processor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_Backend {
    fn default() -> &'a TracingConfiguration_Backend {
        <TracingConfiguration_Backend as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TracingConfiguration_Backend_oneof_span_exporter {
    jaeger_collector_span_exporter(TracingConfiguration_Backend_JaegerCollectorSpanExporter),
    otlp_span_exporter(super::grpc::ClientConfiguration),
}

#[derive(Clone,PartialEq,Debug)]
pub enum TracingConfiguration_Backend_oneof_span_processor {
    simple_span_processor(::protobuf::well_known_types::Empty),
    batch_span_processor(TracingConfiguration_Backend_BatchSpanProcessor),
}

impl TracingConfiguration_Backend {
    pub fn new() -> TracingConfiguration_Backend {
        ::std::default::Default::default()
    }

    // .global.TracingConfiguration.Backend.JaegerCollectorSpanExporter jaeger_collector_span_exporter = 1;


    pub fn get_jaeger_collector_span_exporter(&self) -> &TracingConfiguration_Backend_JaegerCollectorSpanExporter {
        match self.span_exporter {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(ref v)) => v,
            _ => TracingConfiguration_Backend_JaegerCollectorSpanExporter::default_instance(),
        }
    }
    pub fn clear_jaeger_collector_span_exporter(&mut self) {
        self.span_exporter = ::std::option::Option::None;
    }

    pub fn has_jaeger_collector_span_exporter(&self) -> bool {
        match self.span_exporter {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_jaeger_collector_span_exporter(&mut self, v: TracingConfiguration_Backend_JaegerCollectorSpanExporter) {
        self.span_exporter = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_jaeger_collector_span_exporter(&mut self) -> &mut TracingConfiguration_Backend_JaegerCollectorSpanExporter {
        if let ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(_)) = self.span_exporter {
        } else {
            self.span_exporter = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(TracingConfiguration_Backend_JaegerCollectorSpanExporter::new()));
        }
        match self.span_exporter {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_jaeger_collector_span_exporter(&mut self) -> TracingConfiguration_Backend_JaegerCollectorSpanExporter {
        if self.has_jaeger_collector_span_exporter() {
            match self.span_exporter.take() {
                ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(v)) => v,
                _ => panic!(),
            }
        } else {
            TracingConfiguration_Backend_JaegerCollectorSpanExporter::new()
        }
    }

    // .grpc.ClientConfiguration otlp_span_exporter = 4;


    pub fn get_otlp_span_exporter(&self) -> &super::grpc::ClientConfiguration {
        match self.span_exporter {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(ref v)) => v,
            _ => super::grpc::ClientConfiguration::default_instance(),
        }
    }
    pub fn clear_otlp_span_exporter(&mut self) {
        self.span_exporter = ::std::option::Option::None;
    }

    pub fn has_otlp_span_exporter(&self) -> bool {
        match self.span_exporter {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_otlp_span_exporter(&mut self, v: super::grpc::ClientConfiguration) {
        self.span_exporter = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_otlp_span_exporter(&mut self) -> &mut super::grpc::ClientConfiguration {
        if let ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(_)) = self.span_exporter {
        } else {
            self.span_exporter = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(super::grpc::ClientConfiguration::new()));
        }
        match self.span_exporter {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_otlp_span_exporter(&mut self) -> super::grpc::ClientConfiguration {
        if self.has_otlp_span_exporter() {
            match self.span_exporter.take() {
                ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(v)) => v,
                _ => panic!(),
            }
        } else {
            super::grpc::ClientConfiguration::new()
        }
    }

    // .google.protobuf.Empty simple_span_processor = 2;


    pub fn get_simple_span_processor(&self) -> &::protobuf::well_known_types::Empty {
        match self.span_processor {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(ref v)) => v,
            _ => ::protobuf::well_known_types::Empty::default_instance(),
        }
    }
    pub fn clear_simple_span_processor(&mut self) {
        self.span_processor = ::std::option::Option::None;
    }

    pub fn has_simple_span_processor(&self) -> bool {
        match self.span_processor {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_simple_span_processor(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.span_processor = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_simple_span_processor(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(_)) = self.span_processor {
        } else {
            self.span_processor = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(::protobuf::well_known_types::Empty::new()));
        }
        match self.span_processor {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_simple_span_processor(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_simple_span_processor() {
            match self.span_processor.take() {
                ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .global.TracingConfiguration.Backend.BatchSpanProcessor batch_span_processor = 3;


    pub fn get_batch_span_processor(&self) -> &TracingConfiguration_Backend_BatchSpanProcessor {
        match self.span_processor {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(ref v)) => v,
            _ => TracingConfiguration_Backend_BatchSpanProcessor::default_instance(),
        }
    }
    pub fn clear_batch_span_processor(&mut self) {
        self.span_processor = ::std::option::Option::None;
    }

    pub fn has_batch_span_processor(&self) -> bool {
        match self.span_processor {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_batch_span_processor(&mut self, v: TracingConfiguration_Backend_BatchSpanProcessor) {
        self.span_processor = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_batch_span_processor(&mut self) -> &mut TracingConfiguration_Backend_BatchSpanProcessor {
        if let ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(_)) = self.span_processor {
        } else {
            self.span_processor = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(TracingConfiguration_Backend_BatchSpanProcessor::new()));
        }
        match self.span_processor {
            ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_batch_span_processor(&mut self) -> TracingConfiguration_Backend_BatchSpanProcessor {
        if self.has_batch_span_processor() {
            match self.span_processor.take() {
                ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(v)) => v,
                _ => panic!(),
            }
        } else {
            TracingConfiguration_Backend_BatchSpanProcessor::new()
        }
    }
}

impl ::protobuf::Message for TracingConfiguration_Backend {
    fn is_initialized(&self) -> bool {
        if let Some(TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(ref v)) = self.span_exporter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(ref v)) = self.span_exporter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(ref v)) = self.span_processor {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(ref v)) = self.span_processor {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.span_exporter = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.span_exporter = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.span_processor = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.span_processor = ::std::option::Option::Some(TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.span_exporter {
            match v {
                &TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.span_processor {
            match v {
                &TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.span_exporter {
            match v {
                &TracingConfiguration_Backend_oneof_span_exporter::jaeger_collector_span_exporter(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TracingConfiguration_Backend_oneof_span_exporter::otlp_span_exporter(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.span_processor {
            match v {
                &TracingConfiguration_Backend_oneof_span_processor::simple_span_processor(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TracingConfiguration_Backend_oneof_span_processor::batch_span_processor(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_Backend {
        TracingConfiguration_Backend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TracingConfiguration_Backend_JaegerCollectorSpanExporter>(
                    "jaeger_collector_span_exporter",
                    TracingConfiguration_Backend::has_jaeger_collector_span_exporter,
                    TracingConfiguration_Backend::get_jaeger_collector_span_exporter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::grpc::ClientConfiguration>(
                    "otlp_span_exporter",
                    TracingConfiguration_Backend::has_otlp_span_exporter,
                    TracingConfiguration_Backend::get_otlp_span_exporter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                    "simple_span_processor",
                    TracingConfiguration_Backend::has_simple_span_processor,
                    TracingConfiguration_Backend::get_simple_span_processor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TracingConfiguration_Backend_BatchSpanProcessor>(
                    "batch_span_processor",
                    TracingConfiguration_Backend::has_batch_span_processor,
                    TracingConfiguration_Backend::get_batch_span_processor,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_Backend>(
                    "TracingConfiguration_Backend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_Backend {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_Backend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_Backend,
        };
        unsafe {
            instance.get(TracingConfiguration_Backend::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_Backend {
    fn clear(&mut self) {
        self.span_exporter = ::std::option::Option::None;
        self.span_exporter = ::std::option::Option::None;
        self.span_processor = ::std::option::Option::None;
        self.span_processor = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_Backend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_Backend {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_Backend_JaegerCollectorSpanExporter {
    // message fields
    pub endpoint: ::std::string::String,
    pub http_client: ::protobuf::SingularPtrField<super::http::ClientConfiguration>,
    pub password: ::std::string::String,
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_Backend_JaegerCollectorSpanExporter {
    fn default() -> &'a TracingConfiguration_Backend_JaegerCollectorSpanExporter {
        <TracingConfiguration_Backend_JaegerCollectorSpanExporter as ::protobuf::Message>::default_instance()
    }
}

impl TracingConfiguration_Backend_JaegerCollectorSpanExporter {
    pub fn new() -> TracingConfiguration_Backend_JaegerCollectorSpanExporter {
        ::std::default::Default::default()
    }

    // string endpoint = 1;


    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    // .http.ClientConfiguration http_client = 2;


    pub fn get_http_client(&self) -> &super::http::ClientConfiguration {
        self.http_client.as_ref().unwrap_or_else(|| super::http::ClientConfiguration::default_instance())
    }
    pub fn clear_http_client(&mut self) {
        self.http_client.clear();
    }

    pub fn has_http_client(&self) -> bool {
        self.http_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_client(&mut self, v: super::http::ClientConfiguration) {
        self.http_client = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_client(&mut self) -> &mut super::http::ClientConfiguration {
        if self.http_client.is_none() {
            self.http_client.set_default();
        }
        self.http_client.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_client(&mut self) -> super::http::ClientConfiguration {
        self.http_client.take().unwrap_or_else(|| super::http::ClientConfiguration::new())
    }

    // string password = 3;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string username = 4;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TracingConfiguration_Backend_JaegerCollectorSpanExporter {
    fn is_initialized(&self) -> bool {
        for v in &self.http_client {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http_client)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.endpoint);
        }
        if let Some(ref v) = self.http_client.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.password);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.endpoint.is_empty() {
            os.write_string(1, &self.endpoint)?;
        }
        if let Some(ref v) = self.http_client.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.password.is_empty() {
            os.write_string(3, &self.password)?;
        }
        if !self.username.is_empty() {
            os.write_string(4, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_Backend_JaegerCollectorSpanExporter {
        TracingConfiguration_Backend_JaegerCollectorSpanExporter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoint",
                    |m: &TracingConfiguration_Backend_JaegerCollectorSpanExporter| { &m.endpoint },
                    |m: &mut TracingConfiguration_Backend_JaegerCollectorSpanExporter| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::http::ClientConfiguration>>(
                    "http_client",
                    |m: &TracingConfiguration_Backend_JaegerCollectorSpanExporter| { &m.http_client },
                    |m: &mut TracingConfiguration_Backend_JaegerCollectorSpanExporter| { &mut m.http_client },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &TracingConfiguration_Backend_JaegerCollectorSpanExporter| { &m.password },
                    |m: &mut TracingConfiguration_Backend_JaegerCollectorSpanExporter| { &mut m.password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &TracingConfiguration_Backend_JaegerCollectorSpanExporter| { &m.username },
                    |m: &mut TracingConfiguration_Backend_JaegerCollectorSpanExporter| { &mut m.username },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_Backend_JaegerCollectorSpanExporter>(
                    "TracingConfiguration_Backend_JaegerCollectorSpanExporter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_Backend_JaegerCollectorSpanExporter {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_Backend_JaegerCollectorSpanExporter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_Backend_JaegerCollectorSpanExporter,
        };
        unsafe {
            instance.get(TracingConfiguration_Backend_JaegerCollectorSpanExporter::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_Backend_JaegerCollectorSpanExporter {
    fn clear(&mut self) {
        self.endpoint.clear();
        self.http_client.clear();
        self.password.clear();
        self.username.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_Backend_JaegerCollectorSpanExporter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_Backend_JaegerCollectorSpanExporter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_Backend_BatchSpanProcessor {
    // message fields
    pub batch_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub blocking: bool,
    pub export_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub max_export_batch_size: i64,
    pub max_queue_size: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_Backend_BatchSpanProcessor {
    fn default() -> &'a TracingConfiguration_Backend_BatchSpanProcessor {
        <TracingConfiguration_Backend_BatchSpanProcessor as ::protobuf::Message>::default_instance()
    }
}

impl TracingConfiguration_Backend_BatchSpanProcessor {
    pub fn new() -> TracingConfiguration_Backend_BatchSpanProcessor {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration batch_timeout = 1;


    pub fn get_batch_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.batch_timeout.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_batch_timeout(&mut self) {
        self.batch_timeout.clear();
    }

    pub fn has_batch_timeout(&self) -> bool {
        self.batch_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_batch_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.batch_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_batch_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.batch_timeout.is_none() {
            self.batch_timeout.set_default();
        }
        self.batch_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_batch_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.batch_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // bool blocking = 2;


    pub fn get_blocking(&self) -> bool {
        self.blocking
    }
    pub fn clear_blocking(&mut self) {
        self.blocking = false;
    }

    // Param is passed by value, moved
    pub fn set_blocking(&mut self, v: bool) {
        self.blocking = v;
    }

    // .google.protobuf.Duration export_timeout = 3;


    pub fn get_export_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.export_timeout.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_export_timeout(&mut self) {
        self.export_timeout.clear();
    }

    pub fn has_export_timeout(&self) -> bool {
        self.export_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_export_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.export_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_export_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.export_timeout.is_none() {
            self.export_timeout.set_default();
        }
        self.export_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_export_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.export_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // int64 max_export_batch_size = 4;


    pub fn get_max_export_batch_size(&self) -> i64 {
        self.max_export_batch_size
    }
    pub fn clear_max_export_batch_size(&mut self) {
        self.max_export_batch_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_export_batch_size(&mut self, v: i64) {
        self.max_export_batch_size = v;
    }

    // int64 max_queue_size = 5;


    pub fn get_max_queue_size(&self) -> i64 {
        self.max_queue_size
    }
    pub fn clear_max_queue_size(&mut self) {
        self.max_queue_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_queue_size(&mut self, v: i64) {
        self.max_queue_size = v;
    }
}

impl ::protobuf::Message for TracingConfiguration_Backend_BatchSpanProcessor {
    fn is_initialized(&self) -> bool {
        for v in &self.batch_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.export_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.batch_timeout)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blocking = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.export_timeout)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_export_batch_size = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_queue_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.batch_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.blocking != false {
            my_size += 2;
        }
        if let Some(ref v) = self.export_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_export_batch_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_export_batch_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_queue_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.max_queue_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.batch_timeout.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.blocking != false {
            os.write_bool(2, self.blocking)?;
        }
        if let Some(ref v) = self.export_timeout.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_export_batch_size != 0 {
            os.write_int64(4, self.max_export_batch_size)?;
        }
        if self.max_queue_size != 0 {
            os.write_int64(5, self.max_queue_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_Backend_BatchSpanProcessor {
        TracingConfiguration_Backend_BatchSpanProcessor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "batch_timeout",
                    |m: &TracingConfiguration_Backend_BatchSpanProcessor| { &m.batch_timeout },
                    |m: &mut TracingConfiguration_Backend_BatchSpanProcessor| { &mut m.batch_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "blocking",
                    |m: &TracingConfiguration_Backend_BatchSpanProcessor| { &m.blocking },
                    |m: &mut TracingConfiguration_Backend_BatchSpanProcessor| { &mut m.blocking },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "export_timeout",
                    |m: &TracingConfiguration_Backend_BatchSpanProcessor| { &m.export_timeout },
                    |m: &mut TracingConfiguration_Backend_BatchSpanProcessor| { &mut m.export_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "max_export_batch_size",
                    |m: &TracingConfiguration_Backend_BatchSpanProcessor| { &m.max_export_batch_size },
                    |m: &mut TracingConfiguration_Backend_BatchSpanProcessor| { &mut m.max_export_batch_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "max_queue_size",
                    |m: &TracingConfiguration_Backend_BatchSpanProcessor| { &m.max_queue_size },
                    |m: &mut TracingConfiguration_Backend_BatchSpanProcessor| { &mut m.max_queue_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_Backend_BatchSpanProcessor>(
                    "TracingConfiguration_Backend_BatchSpanProcessor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_Backend_BatchSpanProcessor {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_Backend_BatchSpanProcessor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_Backend_BatchSpanProcessor,
        };
        unsafe {
            instance.get(TracingConfiguration_Backend_BatchSpanProcessor::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_Backend_BatchSpanProcessor {
    fn clear(&mut self) {
        self.batch_timeout.clear();
        self.blocking = false;
        self.export_timeout.clear();
        self.max_export_batch_size = 0;
        self.max_queue_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_Backend_BatchSpanProcessor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_Backend_BatchSpanProcessor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_ResourceAttributeValue {
    // message oneof groups
    pub kind: ::std::option::Option<TracingConfiguration_ResourceAttributeValue_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_ResourceAttributeValue {
    fn default() -> &'a TracingConfiguration_ResourceAttributeValue {
        <TracingConfiguration_ResourceAttributeValue as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TracingConfiguration_ResourceAttributeValue_oneof_kind {
    bool(bool),
    int64(i64),
    float64(f64),
    string(::std::string::String),
    bool_array(TracingConfiguration_ResourceAttributeValue_BoolArray),
    int64_array(TracingConfiguration_ResourceAttributeValue_Int64Array),
    float64_array(TracingConfiguration_ResourceAttributeValue_Float64Array),
    string_array(TracingConfiguration_ResourceAttributeValue_StringArray),
}

impl TracingConfiguration_ResourceAttributeValue {
    pub fn new() -> TracingConfiguration_ResourceAttributeValue {
        ::std::default::Default::default()
    }

    // bool bool = 1;


    pub fn get_bool(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool(v)) => v,
            _ => false,
        }
    }
    pub fn clear_bool(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool(v))
    }

    // int64 int64 = 2;


    pub fn get_int64(&self) -> i64 {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int64(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_int64(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int64(&mut self, v: i64) {
        self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64(v))
    }

    // double float64 = 3;


    pub fn get_float64(&self) -> f64 {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float64(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_float64(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float64(&mut self, v: f64) {
        self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64(v))
    }

    // string string = 4;


    pub fn get_string(&self) -> &str {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string(::std::string::String::new()));
        }
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        if self.has_string() {
            match self.kind.take() {
                ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .global.TracingConfiguration.ResourceAttributeValue.BoolArray bool_array = 5;


    pub fn get_bool_array(&self) -> &TracingConfiguration_ResourceAttributeValue_BoolArray {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(ref v)) => v,
            _ => TracingConfiguration_ResourceAttributeValue_BoolArray::default_instance(),
        }
    }
    pub fn clear_bool_array(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_bool_array(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_array(&mut self, v: TracingConfiguration_ResourceAttributeValue_BoolArray) {
        self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bool_array(&mut self) -> &mut TracingConfiguration_ResourceAttributeValue_BoolArray {
        if let ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(TracingConfiguration_ResourceAttributeValue_BoolArray::new()));
        }
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bool_array(&mut self) -> TracingConfiguration_ResourceAttributeValue_BoolArray {
        if self.has_bool_array() {
            match self.kind.take() {
                ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(v)) => v,
                _ => panic!(),
            }
        } else {
            TracingConfiguration_ResourceAttributeValue_BoolArray::new()
        }
    }

    // .global.TracingConfiguration.ResourceAttributeValue.Int64Array int64_array = 6;


    pub fn get_int64_array(&self) -> &TracingConfiguration_ResourceAttributeValue_Int64Array {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(ref v)) => v,
            _ => TracingConfiguration_ResourceAttributeValue_Int64Array::default_instance(),
        }
    }
    pub fn clear_int64_array(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_int64_array(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int64_array(&mut self, v: TracingConfiguration_ResourceAttributeValue_Int64Array) {
        self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(v))
    }

    // Mutable pointer to the field.
    pub fn mut_int64_array(&mut self) -> &mut TracingConfiguration_ResourceAttributeValue_Int64Array {
        if let ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(TracingConfiguration_ResourceAttributeValue_Int64Array::new()));
        }
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_int64_array(&mut self) -> TracingConfiguration_ResourceAttributeValue_Int64Array {
        if self.has_int64_array() {
            match self.kind.take() {
                ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(v)) => v,
                _ => panic!(),
            }
        } else {
            TracingConfiguration_ResourceAttributeValue_Int64Array::new()
        }
    }

    // .global.TracingConfiguration.ResourceAttributeValue.Float64Array float64_array = 7;


    pub fn get_float64_array(&self) -> &TracingConfiguration_ResourceAttributeValue_Float64Array {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(ref v)) => v,
            _ => TracingConfiguration_ResourceAttributeValue_Float64Array::default_instance(),
        }
    }
    pub fn clear_float64_array(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_float64_array(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float64_array(&mut self, v: TracingConfiguration_ResourceAttributeValue_Float64Array) {
        self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(v))
    }

    // Mutable pointer to the field.
    pub fn mut_float64_array(&mut self) -> &mut TracingConfiguration_ResourceAttributeValue_Float64Array {
        if let ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(TracingConfiguration_ResourceAttributeValue_Float64Array::new()));
        }
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_float64_array(&mut self) -> TracingConfiguration_ResourceAttributeValue_Float64Array {
        if self.has_float64_array() {
            match self.kind.take() {
                ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(v)) => v,
                _ => panic!(),
            }
        } else {
            TracingConfiguration_ResourceAttributeValue_Float64Array::new()
        }
    }

    // .global.TracingConfiguration.ResourceAttributeValue.StringArray string_array = 8;


    pub fn get_string_array(&self) -> &TracingConfiguration_ResourceAttributeValue_StringArray {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(ref v)) => v,
            _ => TracingConfiguration_ResourceAttributeValue_StringArray::default_instance(),
        }
    }
    pub fn clear_string_array(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_string_array(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_array(&mut self, v: TracingConfiguration_ResourceAttributeValue_StringArray) {
        self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_array(&mut self) -> &mut TracingConfiguration_ResourceAttributeValue_StringArray {
        if let ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(TracingConfiguration_ResourceAttributeValue_StringArray::new()));
        }
        match self.kind {
            ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_array(&mut self) -> TracingConfiguration_ResourceAttributeValue_StringArray {
        if self.has_string_array() {
            match self.kind.take() {
                ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(v)) => v,
                _ => panic!(),
            }
        } else {
            TracingConfiguration_ResourceAttributeValue_StringArray::new()
        }
    }
}

impl ::protobuf::Message for TracingConfiguration_ResourceAttributeValue {
    fn is_initialized(&self) -> bool {
        if let Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64(is.read_int64()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64(is.read_double()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::bool(v) => {
                    my_size += 2;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::int64(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::float64(v) => {
                    my_size += 9;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::string(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::bool(v) => {
                    os.write_bool(1, v)?;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::int64(v) => {
                    os.write_int64(2, v)?;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::float64(v) => {
                    os.write_double(3, v)?;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::string(ref v) => {
                    os.write_string(4, v)?;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::bool_array(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::int64_array(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::float64_array(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TracingConfiguration_ResourceAttributeValue_oneof_kind::string_array(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_ResourceAttributeValue {
        TracingConfiguration_ResourceAttributeValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "bool",
                    TracingConfiguration_ResourceAttributeValue::has_bool,
                    TracingConfiguration_ResourceAttributeValue::get_bool,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "int64",
                    TracingConfiguration_ResourceAttributeValue::has_int64,
                    TracingConfiguration_ResourceAttributeValue::get_int64,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                    "float64",
                    TracingConfiguration_ResourceAttributeValue::has_float64,
                    TracingConfiguration_ResourceAttributeValue::get_float64,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "string",
                    TracingConfiguration_ResourceAttributeValue::has_string,
                    TracingConfiguration_ResourceAttributeValue::get_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TracingConfiguration_ResourceAttributeValue_BoolArray>(
                    "bool_array",
                    TracingConfiguration_ResourceAttributeValue::has_bool_array,
                    TracingConfiguration_ResourceAttributeValue::get_bool_array,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TracingConfiguration_ResourceAttributeValue_Int64Array>(
                    "int64_array",
                    TracingConfiguration_ResourceAttributeValue::has_int64_array,
                    TracingConfiguration_ResourceAttributeValue::get_int64_array,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TracingConfiguration_ResourceAttributeValue_Float64Array>(
                    "float64_array",
                    TracingConfiguration_ResourceAttributeValue::has_float64_array,
                    TracingConfiguration_ResourceAttributeValue::get_float64_array,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TracingConfiguration_ResourceAttributeValue_StringArray>(
                    "string_array",
                    TracingConfiguration_ResourceAttributeValue::has_string_array,
                    TracingConfiguration_ResourceAttributeValue::get_string_array,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_ResourceAttributeValue>(
                    "TracingConfiguration_ResourceAttributeValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_ResourceAttributeValue {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_ResourceAttributeValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_ResourceAttributeValue,
        };
        unsafe {
            instance.get(TracingConfiguration_ResourceAttributeValue::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_ResourceAttributeValue {
    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_ResourceAttributeValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_ResourceAttributeValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_ResourceAttributeValue_BoolArray {
    // message fields
    pub values: ::std::vec::Vec<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_ResourceAttributeValue_BoolArray {
    fn default() -> &'a TracingConfiguration_ResourceAttributeValue_BoolArray {
        <TracingConfiguration_ResourceAttributeValue_BoolArray as ::protobuf::Message>::default_instance()
    }
}

impl TracingConfiguration_ResourceAttributeValue_BoolArray {
    pub fn new() -> TracingConfiguration_ResourceAttributeValue_BoolArray {
        ::std::default::Default::default()
    }

    // repeated bool values = 1;


    pub fn get_values(&self) -> &[bool] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<bool>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TracingConfiguration_ResourceAttributeValue_BoolArray {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 2 * self.values.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.values {
            os.write_bool(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_ResourceAttributeValue_BoolArray {
        TracingConfiguration_ResourceAttributeValue_BoolArray::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "values",
                    |m: &TracingConfiguration_ResourceAttributeValue_BoolArray| { &m.values },
                    |m: &mut TracingConfiguration_ResourceAttributeValue_BoolArray| { &mut m.values },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_ResourceAttributeValue_BoolArray>(
                    "TracingConfiguration_ResourceAttributeValue_BoolArray",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_ResourceAttributeValue_BoolArray {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_ResourceAttributeValue_BoolArray> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_ResourceAttributeValue_BoolArray,
        };
        unsafe {
            instance.get(TracingConfiguration_ResourceAttributeValue_BoolArray::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_ResourceAttributeValue_BoolArray {
    fn clear(&mut self) {
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_ResourceAttributeValue_BoolArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_ResourceAttributeValue_BoolArray {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_ResourceAttributeValue_Int64Array {
    // message fields
    pub values: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_ResourceAttributeValue_Int64Array {
    fn default() -> &'a TracingConfiguration_ResourceAttributeValue_Int64Array {
        <TracingConfiguration_ResourceAttributeValue_Int64Array as ::protobuf::Message>::default_instance()
    }
}

impl TracingConfiguration_ResourceAttributeValue_Int64Array {
    pub fn new() -> TracingConfiguration_ResourceAttributeValue_Int64Array {
        ::std::default::Default::default()
    }

    // repeated int64 values = 1;


    pub fn get_values(&self) -> &[i64] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<i64>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TracingConfiguration_ResourceAttributeValue_Int64Array {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.values {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.values {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_ResourceAttributeValue_Int64Array {
        TracingConfiguration_ResourceAttributeValue_Int64Array::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "values",
                    |m: &TracingConfiguration_ResourceAttributeValue_Int64Array| { &m.values },
                    |m: &mut TracingConfiguration_ResourceAttributeValue_Int64Array| { &mut m.values },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_ResourceAttributeValue_Int64Array>(
                    "TracingConfiguration_ResourceAttributeValue_Int64Array",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_ResourceAttributeValue_Int64Array {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_ResourceAttributeValue_Int64Array> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_ResourceAttributeValue_Int64Array,
        };
        unsafe {
            instance.get(TracingConfiguration_ResourceAttributeValue_Int64Array::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_ResourceAttributeValue_Int64Array {
    fn clear(&mut self) {
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_ResourceAttributeValue_Int64Array {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_ResourceAttributeValue_Int64Array {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_ResourceAttributeValue_Float64Array {
    // message fields
    pub values: ::std::vec::Vec<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_ResourceAttributeValue_Float64Array {
    fn default() -> &'a TracingConfiguration_ResourceAttributeValue_Float64Array {
        <TracingConfiguration_ResourceAttributeValue_Float64Array as ::protobuf::Message>::default_instance()
    }
}

impl TracingConfiguration_ResourceAttributeValue_Float64Array {
    pub fn new() -> TracingConfiguration_ResourceAttributeValue_Float64Array {
        ::std::default::Default::default()
    }

    // repeated double values = 1;


    pub fn get_values(&self) -> &[f64] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f64>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TracingConfiguration_ResourceAttributeValue_Float64Array {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.values.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.values {
            os.write_double(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_ResourceAttributeValue_Float64Array {
        TracingConfiguration_ResourceAttributeValue_Float64Array::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "values",
                    |m: &TracingConfiguration_ResourceAttributeValue_Float64Array| { &m.values },
                    |m: &mut TracingConfiguration_ResourceAttributeValue_Float64Array| { &mut m.values },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_ResourceAttributeValue_Float64Array>(
                    "TracingConfiguration_ResourceAttributeValue_Float64Array",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_ResourceAttributeValue_Float64Array {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_ResourceAttributeValue_Float64Array> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_ResourceAttributeValue_Float64Array,
        };
        unsafe {
            instance.get(TracingConfiguration_ResourceAttributeValue_Float64Array::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_ResourceAttributeValue_Float64Array {
    fn clear(&mut self) {
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_ResourceAttributeValue_Float64Array {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_ResourceAttributeValue_Float64Array {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_ResourceAttributeValue_StringArray {
    // message fields
    pub values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_ResourceAttributeValue_StringArray {
    fn default() -> &'a TracingConfiguration_ResourceAttributeValue_StringArray {
        <TracingConfiguration_ResourceAttributeValue_StringArray as ::protobuf::Message>::default_instance()
    }
}

impl TracingConfiguration_ResourceAttributeValue_StringArray {
    pub fn new() -> TracingConfiguration_ResourceAttributeValue_StringArray {
        ::std::default::Default::default()
    }

    // repeated string values = 1;


    pub fn get_values(&self) -> &[::std::string::String] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TracingConfiguration_ResourceAttributeValue_StringArray {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.values {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_ResourceAttributeValue_StringArray {
        TracingConfiguration_ResourceAttributeValue_StringArray::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "values",
                    |m: &TracingConfiguration_ResourceAttributeValue_StringArray| { &m.values },
                    |m: &mut TracingConfiguration_ResourceAttributeValue_StringArray| { &mut m.values },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_ResourceAttributeValue_StringArray>(
                    "TracingConfiguration_ResourceAttributeValue_StringArray",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_ResourceAttributeValue_StringArray {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_ResourceAttributeValue_StringArray> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_ResourceAttributeValue_StringArray,
        };
        unsafe {
            instance.get(TracingConfiguration_ResourceAttributeValue_StringArray::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_ResourceAttributeValue_StringArray {
    fn clear(&mut self) {
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_ResourceAttributeValue_StringArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_ResourceAttributeValue_StringArray {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_Sampler {
    // message oneof groups
    pub policy: ::std::option::Option<TracingConfiguration_Sampler_oneof_policy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_Sampler {
    fn default() -> &'a TracingConfiguration_Sampler {
        <TracingConfiguration_Sampler as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TracingConfiguration_Sampler_oneof_policy {
    always(::protobuf::well_known_types::Empty),
    never(::protobuf::well_known_types::Empty),
    parent_based(TracingConfiguration_Sampler_ParentBased),
    trace_id_ratio_based(f64),
    maximum_rate(TracingConfiguration_Sampler_MaximumRate),
}

impl TracingConfiguration_Sampler {
    pub fn new() -> TracingConfiguration_Sampler {
        ::std::default::Default::default()
    }

    // .google.protobuf.Empty always = 1;


    pub fn get_always(&self) -> &::protobuf::well_known_types::Empty {
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::always(ref v)) => v,
            _ => ::protobuf::well_known_types::Empty::default_instance(),
        }
    }
    pub fn clear_always(&mut self) {
        self.policy = ::std::option::Option::None;
    }

    pub fn has_always(&self) -> bool {
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::always(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_always(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::always(v))
    }

    // Mutable pointer to the field.
    pub fn mut_always(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::always(_)) = self.policy {
        } else {
            self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::always(::protobuf::well_known_types::Empty::new()));
        }
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::always(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_always(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_always() {
            match self.policy.take() {
                ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::always(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.Empty never = 2;


    pub fn get_never(&self) -> &::protobuf::well_known_types::Empty {
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::never(ref v)) => v,
            _ => ::protobuf::well_known_types::Empty::default_instance(),
        }
    }
    pub fn clear_never(&mut self) {
        self.policy = ::std::option::Option::None;
    }

    pub fn has_never(&self) -> bool {
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::never(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_never(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::never(v))
    }

    // Mutable pointer to the field.
    pub fn mut_never(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::never(_)) = self.policy {
        } else {
            self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::never(::protobuf::well_known_types::Empty::new()));
        }
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::never(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_never(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_never() {
            match self.policy.take() {
                ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::never(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .global.TracingConfiguration.Sampler.ParentBased parent_based = 3;


    pub fn get_parent_based(&self) -> &TracingConfiguration_Sampler_ParentBased {
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::parent_based(ref v)) => v,
            _ => TracingConfiguration_Sampler_ParentBased::default_instance(),
        }
    }
    pub fn clear_parent_based(&mut self) {
        self.policy = ::std::option::Option::None;
    }

    pub fn has_parent_based(&self) -> bool {
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::parent_based(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parent_based(&mut self, v: TracingConfiguration_Sampler_ParentBased) {
        self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::parent_based(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parent_based(&mut self) -> &mut TracingConfiguration_Sampler_ParentBased {
        if let ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::parent_based(_)) = self.policy {
        } else {
            self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::parent_based(TracingConfiguration_Sampler_ParentBased::new()));
        }
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::parent_based(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parent_based(&mut self) -> TracingConfiguration_Sampler_ParentBased {
        if self.has_parent_based() {
            match self.policy.take() {
                ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::parent_based(v)) => v,
                _ => panic!(),
            }
        } else {
            TracingConfiguration_Sampler_ParentBased::new()
        }
    }

    // double trace_id_ratio_based = 4;


    pub fn get_trace_id_ratio_based(&self) -> f64 {
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::trace_id_ratio_based(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_trace_id_ratio_based(&mut self) {
        self.policy = ::std::option::Option::None;
    }

    pub fn has_trace_id_ratio_based(&self) -> bool {
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::trace_id_ratio_based(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trace_id_ratio_based(&mut self, v: f64) {
        self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::trace_id_ratio_based(v))
    }

    // .global.TracingConfiguration.Sampler.MaximumRate maximum_rate = 5;


    pub fn get_maximum_rate(&self) -> &TracingConfiguration_Sampler_MaximumRate {
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::maximum_rate(ref v)) => v,
            _ => TracingConfiguration_Sampler_MaximumRate::default_instance(),
        }
    }
    pub fn clear_maximum_rate(&mut self) {
        self.policy = ::std::option::Option::None;
    }

    pub fn has_maximum_rate(&self) -> bool {
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::maximum_rate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_maximum_rate(&mut self, v: TracingConfiguration_Sampler_MaximumRate) {
        self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::maximum_rate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_maximum_rate(&mut self) -> &mut TracingConfiguration_Sampler_MaximumRate {
        if let ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::maximum_rate(_)) = self.policy {
        } else {
            self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::maximum_rate(TracingConfiguration_Sampler_MaximumRate::new()));
        }
        match self.policy {
            ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::maximum_rate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_maximum_rate(&mut self) -> TracingConfiguration_Sampler_MaximumRate {
        if self.has_maximum_rate() {
            match self.policy.take() {
                ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::maximum_rate(v)) => v,
                _ => panic!(),
            }
        } else {
            TracingConfiguration_Sampler_MaximumRate::new()
        }
    }
}

impl ::protobuf::Message for TracingConfiguration_Sampler {
    fn is_initialized(&self) -> bool {
        if let Some(TracingConfiguration_Sampler_oneof_policy::always(ref v)) = self.policy {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TracingConfiguration_Sampler_oneof_policy::never(ref v)) = self.policy {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TracingConfiguration_Sampler_oneof_policy::parent_based(ref v)) = self.policy {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TracingConfiguration_Sampler_oneof_policy::maximum_rate(ref v)) = self.policy {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::always(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::never(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::parent_based(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::trace_id_ratio_based(is.read_double()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy = ::std::option::Option::Some(TracingConfiguration_Sampler_oneof_policy::maximum_rate(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.policy {
            match v {
                &TracingConfiguration_Sampler_oneof_policy::always(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TracingConfiguration_Sampler_oneof_policy::never(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TracingConfiguration_Sampler_oneof_policy::parent_based(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TracingConfiguration_Sampler_oneof_policy::trace_id_ratio_based(v) => {
                    my_size += 9;
                },
                &TracingConfiguration_Sampler_oneof_policy::maximum_rate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.policy {
            match v {
                &TracingConfiguration_Sampler_oneof_policy::always(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TracingConfiguration_Sampler_oneof_policy::never(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TracingConfiguration_Sampler_oneof_policy::parent_based(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TracingConfiguration_Sampler_oneof_policy::trace_id_ratio_based(v) => {
                    os.write_double(4, v)?;
                },
                &TracingConfiguration_Sampler_oneof_policy::maximum_rate(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_Sampler {
        TracingConfiguration_Sampler::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                    "always",
                    TracingConfiguration_Sampler::has_always,
                    TracingConfiguration_Sampler::get_always,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                    "never",
                    TracingConfiguration_Sampler::has_never,
                    TracingConfiguration_Sampler::get_never,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TracingConfiguration_Sampler_ParentBased>(
                    "parent_based",
                    TracingConfiguration_Sampler::has_parent_based,
                    TracingConfiguration_Sampler::get_parent_based,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                    "trace_id_ratio_based",
                    TracingConfiguration_Sampler::has_trace_id_ratio_based,
                    TracingConfiguration_Sampler::get_trace_id_ratio_based,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TracingConfiguration_Sampler_MaximumRate>(
                    "maximum_rate",
                    TracingConfiguration_Sampler::has_maximum_rate,
                    TracingConfiguration_Sampler::get_maximum_rate,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_Sampler>(
                    "TracingConfiguration_Sampler",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_Sampler {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_Sampler> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_Sampler,
        };
        unsafe {
            instance.get(TracingConfiguration_Sampler::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_Sampler {
    fn clear(&mut self) {
        self.policy = ::std::option::Option::None;
        self.policy = ::std::option::Option::None;
        self.policy = ::std::option::Option::None;
        self.policy = ::std::option::Option::None;
        self.policy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_Sampler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_Sampler {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_Sampler_ParentBased {
    // message fields
    pub no_parent: ::protobuf::SingularPtrField<TracingConfiguration_Sampler>,
    pub local_parent_not_sampled: ::protobuf::SingularPtrField<TracingConfiguration_Sampler>,
    pub local_parent_sampled: ::protobuf::SingularPtrField<TracingConfiguration_Sampler>,
    pub remote_parent_not_sampled: ::protobuf::SingularPtrField<TracingConfiguration_Sampler>,
    pub remote_parent_sampled: ::protobuf::SingularPtrField<TracingConfiguration_Sampler>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_Sampler_ParentBased {
    fn default() -> &'a TracingConfiguration_Sampler_ParentBased {
        <TracingConfiguration_Sampler_ParentBased as ::protobuf::Message>::default_instance()
    }
}

impl TracingConfiguration_Sampler_ParentBased {
    pub fn new() -> TracingConfiguration_Sampler_ParentBased {
        ::std::default::Default::default()
    }

    // .global.TracingConfiguration.Sampler no_parent = 1;


    pub fn get_no_parent(&self) -> &TracingConfiguration_Sampler {
        self.no_parent.as_ref().unwrap_or_else(|| TracingConfiguration_Sampler::default_instance())
    }
    pub fn clear_no_parent(&mut self) {
        self.no_parent.clear();
    }

    pub fn has_no_parent(&self) -> bool {
        self.no_parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_parent(&mut self, v: TracingConfiguration_Sampler) {
        self.no_parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_no_parent(&mut self) -> &mut TracingConfiguration_Sampler {
        if self.no_parent.is_none() {
            self.no_parent.set_default();
        }
        self.no_parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_no_parent(&mut self) -> TracingConfiguration_Sampler {
        self.no_parent.take().unwrap_or_else(|| TracingConfiguration_Sampler::new())
    }

    // .global.TracingConfiguration.Sampler local_parent_not_sampled = 2;


    pub fn get_local_parent_not_sampled(&self) -> &TracingConfiguration_Sampler {
        self.local_parent_not_sampled.as_ref().unwrap_or_else(|| TracingConfiguration_Sampler::default_instance())
    }
    pub fn clear_local_parent_not_sampled(&mut self) {
        self.local_parent_not_sampled.clear();
    }

    pub fn has_local_parent_not_sampled(&self) -> bool {
        self.local_parent_not_sampled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_parent_not_sampled(&mut self, v: TracingConfiguration_Sampler) {
        self.local_parent_not_sampled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_parent_not_sampled(&mut self) -> &mut TracingConfiguration_Sampler {
        if self.local_parent_not_sampled.is_none() {
            self.local_parent_not_sampled.set_default();
        }
        self.local_parent_not_sampled.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_parent_not_sampled(&mut self) -> TracingConfiguration_Sampler {
        self.local_parent_not_sampled.take().unwrap_or_else(|| TracingConfiguration_Sampler::new())
    }

    // .global.TracingConfiguration.Sampler local_parent_sampled = 3;


    pub fn get_local_parent_sampled(&self) -> &TracingConfiguration_Sampler {
        self.local_parent_sampled.as_ref().unwrap_or_else(|| TracingConfiguration_Sampler::default_instance())
    }
    pub fn clear_local_parent_sampled(&mut self) {
        self.local_parent_sampled.clear();
    }

    pub fn has_local_parent_sampled(&self) -> bool {
        self.local_parent_sampled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_parent_sampled(&mut self, v: TracingConfiguration_Sampler) {
        self.local_parent_sampled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_parent_sampled(&mut self) -> &mut TracingConfiguration_Sampler {
        if self.local_parent_sampled.is_none() {
            self.local_parent_sampled.set_default();
        }
        self.local_parent_sampled.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_parent_sampled(&mut self) -> TracingConfiguration_Sampler {
        self.local_parent_sampled.take().unwrap_or_else(|| TracingConfiguration_Sampler::new())
    }

    // .global.TracingConfiguration.Sampler remote_parent_not_sampled = 4;


    pub fn get_remote_parent_not_sampled(&self) -> &TracingConfiguration_Sampler {
        self.remote_parent_not_sampled.as_ref().unwrap_or_else(|| TracingConfiguration_Sampler::default_instance())
    }
    pub fn clear_remote_parent_not_sampled(&mut self) {
        self.remote_parent_not_sampled.clear();
    }

    pub fn has_remote_parent_not_sampled(&self) -> bool {
        self.remote_parent_not_sampled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_parent_not_sampled(&mut self, v: TracingConfiguration_Sampler) {
        self.remote_parent_not_sampled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_parent_not_sampled(&mut self) -> &mut TracingConfiguration_Sampler {
        if self.remote_parent_not_sampled.is_none() {
            self.remote_parent_not_sampled.set_default();
        }
        self.remote_parent_not_sampled.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_parent_not_sampled(&mut self) -> TracingConfiguration_Sampler {
        self.remote_parent_not_sampled.take().unwrap_or_else(|| TracingConfiguration_Sampler::new())
    }

    // .global.TracingConfiguration.Sampler remote_parent_sampled = 5;


    pub fn get_remote_parent_sampled(&self) -> &TracingConfiguration_Sampler {
        self.remote_parent_sampled.as_ref().unwrap_or_else(|| TracingConfiguration_Sampler::default_instance())
    }
    pub fn clear_remote_parent_sampled(&mut self) {
        self.remote_parent_sampled.clear();
    }

    pub fn has_remote_parent_sampled(&self) -> bool {
        self.remote_parent_sampled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_parent_sampled(&mut self, v: TracingConfiguration_Sampler) {
        self.remote_parent_sampled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_parent_sampled(&mut self) -> &mut TracingConfiguration_Sampler {
        if self.remote_parent_sampled.is_none() {
            self.remote_parent_sampled.set_default();
        }
        self.remote_parent_sampled.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_parent_sampled(&mut self) -> TracingConfiguration_Sampler {
        self.remote_parent_sampled.take().unwrap_or_else(|| TracingConfiguration_Sampler::new())
    }
}

impl ::protobuf::Message for TracingConfiguration_Sampler_ParentBased {
    fn is_initialized(&self) -> bool {
        for v in &self.no_parent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local_parent_not_sampled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local_parent_sampled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remote_parent_not_sampled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remote_parent_sampled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.no_parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_parent_not_sampled)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_parent_sampled)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remote_parent_not_sampled)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remote_parent_sampled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.no_parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.local_parent_not_sampled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.local_parent_sampled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remote_parent_not_sampled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remote_parent_sampled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.no_parent.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.local_parent_not_sampled.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.local_parent_sampled.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remote_parent_not_sampled.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remote_parent_sampled.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_Sampler_ParentBased {
        TracingConfiguration_Sampler_ParentBased::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_Sampler>>(
                    "no_parent",
                    |m: &TracingConfiguration_Sampler_ParentBased| { &m.no_parent },
                    |m: &mut TracingConfiguration_Sampler_ParentBased| { &mut m.no_parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_Sampler>>(
                    "local_parent_not_sampled",
                    |m: &TracingConfiguration_Sampler_ParentBased| { &m.local_parent_not_sampled },
                    |m: &mut TracingConfiguration_Sampler_ParentBased| { &mut m.local_parent_not_sampled },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_Sampler>>(
                    "local_parent_sampled",
                    |m: &TracingConfiguration_Sampler_ParentBased| { &m.local_parent_sampled },
                    |m: &mut TracingConfiguration_Sampler_ParentBased| { &mut m.local_parent_sampled },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_Sampler>>(
                    "remote_parent_not_sampled",
                    |m: &TracingConfiguration_Sampler_ParentBased| { &m.remote_parent_not_sampled },
                    |m: &mut TracingConfiguration_Sampler_ParentBased| { &mut m.remote_parent_not_sampled },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration_Sampler>>(
                    "remote_parent_sampled",
                    |m: &TracingConfiguration_Sampler_ParentBased| { &m.remote_parent_sampled },
                    |m: &mut TracingConfiguration_Sampler_ParentBased| { &mut m.remote_parent_sampled },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_Sampler_ParentBased>(
                    "TracingConfiguration_Sampler_ParentBased",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_Sampler_ParentBased {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_Sampler_ParentBased> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_Sampler_ParentBased,
        };
        unsafe {
            instance.get(TracingConfiguration_Sampler_ParentBased::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_Sampler_ParentBased {
    fn clear(&mut self) {
        self.no_parent.clear();
        self.local_parent_not_sampled.clear();
        self.local_parent_sampled.clear();
        self.remote_parent_not_sampled.clear();
        self.remote_parent_sampled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_Sampler_ParentBased {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_Sampler_ParentBased {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingConfiguration_Sampler_MaximumRate {
    // message fields
    pub samples_per_epoch: i64,
    pub epoch_duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingConfiguration_Sampler_MaximumRate {
    fn default() -> &'a TracingConfiguration_Sampler_MaximumRate {
        <TracingConfiguration_Sampler_MaximumRate as ::protobuf::Message>::default_instance()
    }
}

impl TracingConfiguration_Sampler_MaximumRate {
    pub fn new() -> TracingConfiguration_Sampler_MaximumRate {
        ::std::default::Default::default()
    }

    // int64 samples_per_epoch = 1;


    pub fn get_samples_per_epoch(&self) -> i64 {
        self.samples_per_epoch
    }
    pub fn clear_samples_per_epoch(&mut self) {
        self.samples_per_epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_samples_per_epoch(&mut self, v: i64) {
        self.samples_per_epoch = v;
    }

    // .google.protobuf.Duration epoch_duration = 2;


    pub fn get_epoch_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.epoch_duration.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_epoch_duration(&mut self) {
        self.epoch_duration.clear();
    }

    pub fn has_epoch_duration(&self) -> bool {
        self.epoch_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epoch_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.epoch_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epoch_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.epoch_duration.is_none() {
            self.epoch_duration.set_default();
        }
        self.epoch_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_epoch_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.epoch_duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for TracingConfiguration_Sampler_MaximumRate {
    fn is_initialized(&self) -> bool {
        for v in &self.epoch_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.samples_per_epoch = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epoch_duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.samples_per_epoch != 0 {
            my_size += ::protobuf::rt::value_size(1, self.samples_per_epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.epoch_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.samples_per_epoch != 0 {
            os.write_int64(1, self.samples_per_epoch)?;
        }
        if let Some(ref v) = self.epoch_duration.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingConfiguration_Sampler_MaximumRate {
        TracingConfiguration_Sampler_MaximumRate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "samples_per_epoch",
                    |m: &TracingConfiguration_Sampler_MaximumRate| { &m.samples_per_epoch },
                    |m: &mut TracingConfiguration_Sampler_MaximumRate| { &mut m.samples_per_epoch },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "epoch_duration",
                    |m: &TracingConfiguration_Sampler_MaximumRate| { &m.epoch_duration },
                    |m: &mut TracingConfiguration_Sampler_MaximumRate| { &mut m.epoch_duration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TracingConfiguration_Sampler_MaximumRate>(
                    "TracingConfiguration_Sampler_MaximumRate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TracingConfiguration_Sampler_MaximumRate {
        static mut instance: ::protobuf::lazy::Lazy<TracingConfiguration_Sampler_MaximumRate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TracingConfiguration_Sampler_MaximumRate,
        };
        unsafe {
            instance.get(TracingConfiguration_Sampler_MaximumRate::new)
        }
    }
}

impl ::protobuf::Clear for TracingConfiguration_Sampler_MaximumRate {
    fn clear(&mut self) {
        self.samples_per_epoch = 0;
        self.epoch_duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingConfiguration_Sampler_MaximumRate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingConfiguration_Sampler_MaximumRate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetUmaskConfiguration {
    // message fields
    pub umask: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetUmaskConfiguration {
    fn default() -> &'a SetUmaskConfiguration {
        <SetUmaskConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl SetUmaskConfiguration {
    pub fn new() -> SetUmaskConfiguration {
        ::std::default::Default::default()
    }

    // uint32 umask = 1;


    pub fn get_umask(&self) -> u32 {
        self.umask
    }
    pub fn clear_umask(&mut self) {
        self.umask = 0;
    }

    // Param is passed by value, moved
    pub fn set_umask(&mut self, v: u32) {
        self.umask = v;
    }
}

impl ::protobuf::Message for SetUmaskConfiguration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.umask = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.umask != 0 {
            my_size += ::protobuf::rt::value_size(1, self.umask, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.umask != 0 {
            os.write_uint32(1, self.umask)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetUmaskConfiguration {
        SetUmaskConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "umask",
                    |m: &SetUmaskConfiguration| { &m.umask },
                    |m: &mut SetUmaskConfiguration| { &mut m.umask },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetUmaskConfiguration>(
                    "SetUmaskConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetUmaskConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<SetUmaskConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetUmaskConfiguration,
        };
        unsafe {
            instance.get(SetUmaskConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for SetUmaskConfiguration {
    fn clear(&mut self) {
        self.umask = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetUmaskConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetUmaskConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Configuration {
    // message fields
    pub tracing: ::protobuf::SingularPtrField<TracingConfiguration>,
    pub mutex_profile_fraction: i32,
    pub prometheus_pushgateway: ::protobuf::SingularPtrField<PrometheusPushgatewayConfiguration>,
    pub log_paths: ::protobuf::RepeatedField<::std::string::String>,
    pub diagnostics_http_server: ::protobuf::SingularPtrField<DiagnosticsHTTPServerConfiguration>,
    pub set_umask: ::protobuf::SingularPtrField<SetUmaskConfiguration>,
    pub grpc_forward_and_reuse_metadata: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Configuration {
    fn default() -> &'a Configuration {
        <Configuration as ::protobuf::Message>::default_instance()
    }
}

impl Configuration {
    pub fn new() -> Configuration {
        ::std::default::Default::default()
    }

    // .global.TracingConfiguration tracing = 1;


    pub fn get_tracing(&self) -> &TracingConfiguration {
        self.tracing.as_ref().unwrap_or_else(|| TracingConfiguration::default_instance())
    }
    pub fn clear_tracing(&mut self) {
        self.tracing.clear();
    }

    pub fn has_tracing(&self) -> bool {
        self.tracing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracing(&mut self, v: TracingConfiguration) {
        self.tracing = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tracing(&mut self) -> &mut TracingConfiguration {
        if self.tracing.is_none() {
            self.tracing.set_default();
        }
        self.tracing.as_mut().unwrap()
    }

    // Take field
    pub fn take_tracing(&mut self) -> TracingConfiguration {
        self.tracing.take().unwrap_or_else(|| TracingConfiguration::new())
    }

    // int32 mutex_profile_fraction = 2;


    pub fn get_mutex_profile_fraction(&self) -> i32 {
        self.mutex_profile_fraction
    }
    pub fn clear_mutex_profile_fraction(&mut self) {
        self.mutex_profile_fraction = 0;
    }

    // Param is passed by value, moved
    pub fn set_mutex_profile_fraction(&mut self, v: i32) {
        self.mutex_profile_fraction = v;
    }

    // .global.PrometheusPushgatewayConfiguration prometheus_pushgateway = 3;


    pub fn get_prometheus_pushgateway(&self) -> &PrometheusPushgatewayConfiguration {
        self.prometheus_pushgateway.as_ref().unwrap_or_else(|| PrometheusPushgatewayConfiguration::default_instance())
    }
    pub fn clear_prometheus_pushgateway(&mut self) {
        self.prometheus_pushgateway.clear();
    }

    pub fn has_prometheus_pushgateway(&self) -> bool {
        self.prometheus_pushgateway.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prometheus_pushgateway(&mut self, v: PrometheusPushgatewayConfiguration) {
        self.prometheus_pushgateway = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prometheus_pushgateway(&mut self) -> &mut PrometheusPushgatewayConfiguration {
        if self.prometheus_pushgateway.is_none() {
            self.prometheus_pushgateway.set_default();
        }
        self.prometheus_pushgateway.as_mut().unwrap()
    }

    // Take field
    pub fn take_prometheus_pushgateway(&mut self) -> PrometheusPushgatewayConfiguration {
        self.prometheus_pushgateway.take().unwrap_or_else(|| PrometheusPushgatewayConfiguration::new())
    }

    // repeated string log_paths = 5;


    pub fn get_log_paths(&self) -> &[::std::string::String] {
        &self.log_paths
    }
    pub fn clear_log_paths(&mut self) {
        self.log_paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_paths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.log_paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_log_paths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.log_paths
    }

    // Take field
    pub fn take_log_paths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.log_paths, ::protobuf::RepeatedField::new())
    }

    // .global.DiagnosticsHTTPServerConfiguration diagnostics_http_server = 6;


    pub fn get_diagnostics_http_server(&self) -> &DiagnosticsHTTPServerConfiguration {
        self.diagnostics_http_server.as_ref().unwrap_or_else(|| DiagnosticsHTTPServerConfiguration::default_instance())
    }
    pub fn clear_diagnostics_http_server(&mut self) {
        self.diagnostics_http_server.clear();
    }

    pub fn has_diagnostics_http_server(&self) -> bool {
        self.diagnostics_http_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostics_http_server(&mut self, v: DiagnosticsHTTPServerConfiguration) {
        self.diagnostics_http_server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diagnostics_http_server(&mut self) -> &mut DiagnosticsHTTPServerConfiguration {
        if self.diagnostics_http_server.is_none() {
            self.diagnostics_http_server.set_default();
        }
        self.diagnostics_http_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_diagnostics_http_server(&mut self) -> DiagnosticsHTTPServerConfiguration {
        self.diagnostics_http_server.take().unwrap_or_else(|| DiagnosticsHTTPServerConfiguration::new())
    }

    // .global.SetUmaskConfiguration set_umask = 7;


    pub fn get_set_umask(&self) -> &SetUmaskConfiguration {
        self.set_umask.as_ref().unwrap_or_else(|| SetUmaskConfiguration::default_instance())
    }
    pub fn clear_set_umask(&mut self) {
        self.set_umask.clear();
    }

    pub fn has_set_umask(&self) -> bool {
        self.set_umask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_umask(&mut self, v: SetUmaskConfiguration) {
        self.set_umask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set_umask(&mut self) -> &mut SetUmaskConfiguration {
        if self.set_umask.is_none() {
            self.set_umask.set_default();
        }
        self.set_umask.as_mut().unwrap()
    }

    // Take field
    pub fn take_set_umask(&mut self) -> SetUmaskConfiguration {
        self.set_umask.take().unwrap_or_else(|| SetUmaskConfiguration::new())
    }

    // repeated string grpc_forward_and_reuse_metadata = 8;


    pub fn get_grpc_forward_and_reuse_metadata(&self) -> &[::std::string::String] {
        &self.grpc_forward_and_reuse_metadata
    }
    pub fn clear_grpc_forward_and_reuse_metadata(&mut self) {
        self.grpc_forward_and_reuse_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_grpc_forward_and_reuse_metadata(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.grpc_forward_and_reuse_metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_grpc_forward_and_reuse_metadata(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.grpc_forward_and_reuse_metadata
    }

    // Take field
    pub fn take_grpc_forward_and_reuse_metadata(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.grpc_forward_and_reuse_metadata, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Configuration {
    fn is_initialized(&self) -> bool {
        for v in &self.tracing {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prometheus_pushgateway {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.diagnostics_http_server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_umask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tracing)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mutex_profile_fraction = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prometheus_pushgateway)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.log_paths)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.diagnostics_http_server)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.set_umask)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.grpc_forward_and_reuse_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tracing.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.mutex_profile_fraction != 0 {
            my_size += ::protobuf::rt::value_size(2, self.mutex_profile_fraction, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.prometheus_pushgateway.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.log_paths {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(ref v) = self.diagnostics_http_server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.set_umask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.grpc_forward_and_reuse_metadata {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tracing.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.mutex_profile_fraction != 0 {
            os.write_int32(2, self.mutex_profile_fraction)?;
        }
        if let Some(ref v) = self.prometheus_pushgateway.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.log_paths {
            os.write_string(5, &v)?;
        };
        if let Some(ref v) = self.diagnostics_http_server.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.set_umask.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.grpc_forward_and_reuse_metadata {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Configuration {
        Configuration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TracingConfiguration>>(
                    "tracing",
                    |m: &Configuration| { &m.tracing },
                    |m: &mut Configuration| { &mut m.tracing },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mutex_profile_fraction",
                    |m: &Configuration| { &m.mutex_profile_fraction },
                    |m: &mut Configuration| { &mut m.mutex_profile_fraction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PrometheusPushgatewayConfiguration>>(
                    "prometheus_pushgateway",
                    |m: &Configuration| { &m.prometheus_pushgateway },
                    |m: &mut Configuration| { &mut m.prometheus_pushgateway },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "log_paths",
                    |m: &Configuration| { &m.log_paths },
                    |m: &mut Configuration| { &mut m.log_paths },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiagnosticsHTTPServerConfiguration>>(
                    "diagnostics_http_server",
                    |m: &Configuration| { &m.diagnostics_http_server },
                    |m: &mut Configuration| { &mut m.diagnostics_http_server },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SetUmaskConfiguration>>(
                    "set_umask",
                    |m: &Configuration| { &m.set_umask },
                    |m: &mut Configuration| { &mut m.set_umask },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "grpc_forward_and_reuse_metadata",
                    |m: &Configuration| { &m.grpc_forward_and_reuse_metadata },
                    |m: &mut Configuration| { &mut m.grpc_forward_and_reuse_metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Configuration>(
                    "Configuration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Configuration {
        static mut instance: ::protobuf::lazy::Lazy<Configuration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Configuration,
        };
        unsafe {
            instance.get(Configuration::new)
        }
    }
}

impl ::protobuf::Clear for Configuration {
    fn clear(&mut self) {
        self.tracing.clear();
        self.mutex_profile_fraction = 0;
        self.prometheus_pushgateway.clear();
        self.log_paths.clear();
        self.diagnostics_http_server.clear();
        self.set_umask.clear();
        self.grpc_forward_and_reuse_metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Configuration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiagnosticsHTTPServerConfiguration {
    // message fields
    pub listen_address: ::std::string::String,
    pub enable_pprof: bool,
    pub enable_prometheus: bool,
    pub enable_active_spans: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DiagnosticsHTTPServerConfiguration {
    fn default() -> &'a DiagnosticsHTTPServerConfiguration {
        <DiagnosticsHTTPServerConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DiagnosticsHTTPServerConfiguration {
    pub fn new() -> DiagnosticsHTTPServerConfiguration {
        ::std::default::Default::default()
    }

    // string listen_address = 1;


    pub fn get_listen_address(&self) -> &str {
        &self.listen_address
    }
    pub fn clear_listen_address(&mut self) {
        self.listen_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_listen_address(&mut self, v: ::std::string::String) {
        self.listen_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listen_address(&mut self) -> &mut ::std::string::String {
        &mut self.listen_address
    }

    // Take field
    pub fn take_listen_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.listen_address, ::std::string::String::new())
    }

    // bool enable_pprof = 2;


    pub fn get_enable_pprof(&self) -> bool {
        self.enable_pprof
    }
    pub fn clear_enable_pprof(&mut self) {
        self.enable_pprof = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_pprof(&mut self, v: bool) {
        self.enable_pprof = v;
    }

    // bool enable_prometheus = 3;


    pub fn get_enable_prometheus(&self) -> bool {
        self.enable_prometheus
    }
    pub fn clear_enable_prometheus(&mut self) {
        self.enable_prometheus = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_prometheus(&mut self, v: bool) {
        self.enable_prometheus = v;
    }

    // bool enable_active_spans = 4;


    pub fn get_enable_active_spans(&self) -> bool {
        self.enable_active_spans
    }
    pub fn clear_enable_active_spans(&mut self) {
        self.enable_active_spans = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_active_spans(&mut self, v: bool) {
        self.enable_active_spans = v;
    }
}

impl ::protobuf::Message for DiagnosticsHTTPServerConfiguration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.listen_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_pprof = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_prometheus = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_active_spans = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.listen_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.listen_address);
        }
        if self.enable_pprof != false {
            my_size += 2;
        }
        if self.enable_prometheus != false {
            my_size += 2;
        }
        if self.enable_active_spans != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.listen_address.is_empty() {
            os.write_string(1, &self.listen_address)?;
        }
        if self.enable_pprof != false {
            os.write_bool(2, self.enable_pprof)?;
        }
        if self.enable_prometheus != false {
            os.write_bool(3, self.enable_prometheus)?;
        }
        if self.enable_active_spans != false {
            os.write_bool(4, self.enable_active_spans)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiagnosticsHTTPServerConfiguration {
        DiagnosticsHTTPServerConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "listen_address",
                    |m: &DiagnosticsHTTPServerConfiguration| { &m.listen_address },
                    |m: &mut DiagnosticsHTTPServerConfiguration| { &mut m.listen_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_pprof",
                    |m: &DiagnosticsHTTPServerConfiguration| { &m.enable_pprof },
                    |m: &mut DiagnosticsHTTPServerConfiguration| { &mut m.enable_pprof },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_prometheus",
                    |m: &DiagnosticsHTTPServerConfiguration| { &m.enable_prometheus },
                    |m: &mut DiagnosticsHTTPServerConfiguration| { &mut m.enable_prometheus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_active_spans",
                    |m: &DiagnosticsHTTPServerConfiguration| { &m.enable_active_spans },
                    |m: &mut DiagnosticsHTTPServerConfiguration| { &mut m.enable_active_spans },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DiagnosticsHTTPServerConfiguration>(
                    "DiagnosticsHTTPServerConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DiagnosticsHTTPServerConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<DiagnosticsHTTPServerConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DiagnosticsHTTPServerConfiguration,
        };
        unsafe {
            instance.get(DiagnosticsHTTPServerConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for DiagnosticsHTTPServerConfiguration {
    fn clear(&mut self) {
        self.listen_address.clear();
        self.enable_pprof = false;
        self.enable_prometheus = false;
        self.enable_active_spans = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiagnosticsHTTPServerConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiagnosticsHTTPServerConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n'proto/configuration/global/global.proto\x12\x06global\x1a\x1egoogle/p\
    rotobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a#proto/conf\
    iguration/grpc/grpc.proto\x1a#proto/configuration/http/http.proto\"\xdd\
    \x02\n\"PrometheusPushgatewayConfiguration\x12\x10\n\x03url\x18\x01\x20\
    \x01(\tR\x03url\x12\x10\n\x03job\x18\x02\x20\x01(\tR\x03job\x12T\n\x08gr\
    ouping\x18\x04\x20\x03(\x0b28.global.PrometheusPushgatewayConfiguration.\
    GroupingEntryR\x08grouping\x12>\n\rpush_interval\x18\x05\x20\x01(\x0b2\
    \x19.google.protobuf.DurationR\x0cpushInterval\x12:\n\x0bhttp_client\x18\
    \x06\x20\x01(\x0b2\x19.http.ClientConfigurationR\nhttpClient\x1a;\n\rGro\
    upingEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05valu\
    e\x18\x02\x20\x01(\tR\x05value:\x028\x01J\x04\x08\x03\x10\x04\"\xc6\x16\
    \n\x14TracingConfiguration\x12@\n\x08backends\x18\x01\x20\x03(\x0b2$.glo\
    bal.TracingConfiguration.BackendR\x08backends\x12e\n\x13resource_attribu\
    tes\x18\x02\x20\x03(\x0b24.global.TracingConfiguration.ResourceAttribute\
    sEntryR\x12resourceAttributes\x12>\n\x07sampler\x18\x03\x20\x01(\x0b2$.g\
    lobal.TracingConfiguration.SamplerR\x07sampler\x1a\xfa\x06\n\x07Backend\
    \x12\x87\x01\n\x1ejaeger_collector_span_exporter\x18\x01\x20\x01(\x0b2@.\
    global.TracingConfiguration.Backend.JaegerCollectorSpanExporterH\0R\x1bj\
    aegerCollectorSpanExporter\x12I\n\x12otlp_span_exporter\x18\x04\x20\x01(\
    \x0b2\x19.grpc.ClientConfigurationH\0R\x10otlpSpanExporter\x12L\n\x15sim\
    ple_span_processor\x18\x02\x20\x01(\x0b2\x16.google.protobuf.EmptyH\x01R\
    \x13simpleSpanProcessor\x12k\n\x14batch_span_processor\x18\x03\x20\x01(\
    \x0b27.global.TracingConfiguration.Backend.BatchSpanProcessorH\x01R\x12b\
    atchSpanProcessor\x1a\xad\x01\n\x1bJaegerCollectorSpanExporter\x12\x1a\n\
    \x08endpoint\x18\x01\x20\x01(\tR\x08endpoint\x12:\n\x0bhttp_client\x18\
    \x02\x20\x01(\x0b2\x19.http.ClientConfigurationR\nhttpClient\x12\x1a\n\
    \x08password\x18\x03\x20\x01(\tR\x08password\x12\x1a\n\x08username\x18\
    \x04\x20\x01(\tR\x08username\x1a\x8b\x02\n\x12BatchSpanProcessor\x12>\n\
    \rbatch_timeout\x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0cb\
    atchTimeout\x12\x1a\n\x08blocking\x18\x02\x20\x01(\x08R\x08blocking\x12@\
    \n\x0eexport_timeout\x18\x03\x20\x01(\x0b2\x19.google.protobuf.DurationR\
    \rexportTimeout\x121\n\x15max_export_batch_size\x18\x04\x20\x01(\x03R\
    \x12maxExportBatchSize\x12$\n\x0emax_queue_size\x18\x05\x20\x01(\x03R\
    \x0cmaxQueueSizeB\x0f\n\rspan_exporterB\x10\n\x0espan_processor\x1a\xb0\
    \x05\n\x16ResourceAttributeValue\x12\x14\n\x04bool\x18\x01\x20\x01(\x08H\
    \0R\x04bool\x12\x16\n\x05int64\x18\x02\x20\x01(\x03H\0R\x05int64\x12\x1a\
    \n\x07float64\x18\x03\x20\x01(\x01H\0R\x07float64\x12\x18\n\x06string\
    \x18\x04\x20\x01(\tH\0R\x06string\x12^\n\nbool_array\x18\x05\x20\x01(\
    \x0b2=.global.TracingConfiguration.ResourceAttributeValue.BoolArrayH\0R\
    \tboolArray\x12a\n\x0bint64_array\x18\x06\x20\x01(\x0b2>.global.TracingC\
    onfiguration.ResourceAttributeValue.Int64ArrayH\0R\nint64Array\x12g\n\rf\
    loat64_array\x18\x07\x20\x01(\x0b2@.global.TracingConfiguration.Resource\
    AttributeValue.Float64ArrayH\0R\x0cfloat64Array\x12d\n\x0cstring_array\
    \x18\x08\x20\x01(\x0b2?.global.TracingConfiguration.ResourceAttributeVal\
    ue.StringArrayH\0R\x0bstringArray\x1a#\n\tBoolArray\x12\x16\n\x06values\
    \x18\x01\x20\x03(\x08R\x06values\x1a$\n\nInt64Array\x12\x16\n\x06values\
    \x18\x01\x20\x03(\x03R\x06values\x1a&\n\x0cFloat64Array\x12\x16\n\x06val\
    ues\x18\x01\x20\x03(\x01R\x06values\x1a%\n\x0bStringArray\x12\x16\n\x06v\
    alues\x18\x01\x20\x03(\tR\x06valuesB\x06\n\x04kind\x1az\n\x17ResourceAtt\
    ributesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12I\n\x05value\
    \x18\x02\x20\x01(\x0b23.global.TracingConfiguration.ResourceAttributeVal\
    ueR\x05value:\x028\x01\x1a\x98\x07\n\x07Sampler\x120\n\x06always\x18\x01\
    \x20\x01(\x0b2\x16.google.protobuf.EmptyH\0R\x06always\x12.\n\x05never\
    \x18\x02\x20\x01(\x0b2\x16.google.protobuf.EmptyH\0R\x05never\x12U\n\x0c\
    parent_based\x18\x03\x20\x01(\x0b20.global.TracingConfiguration.Sampler.\
    ParentBasedH\0R\x0bparentBased\x121\n\x14trace_id_ratio_based\x18\x04\
    \x20\x01(\x01H\0R\x11traceIdRatioBased\x12U\n\x0cmaximum_rate\x18\x05\
    \x20\x01(\x0b20.global.TracingConfiguration.Sampler.MaximumRateH\0R\x0bm\
    aximumRate\x1a\xc2\x03\n\x0bParentBased\x12A\n\tno_parent\x18\x01\x20\
    \x01(\x0b2$.global.TracingConfiguration.SamplerR\x08noParent\x12]\n\x18l\
    ocal_parent_not_sampled\x18\x02\x20\x01(\x0b2$.global.TracingConfigurati\
    on.SamplerR\x15localParentNotSampled\x12V\n\x14local_parent_sampled\x18\
    \x03\x20\x01(\x0b2$.global.TracingConfiguration.SamplerR\x12localParentS\
    ampled\x12_\n\x19remote_parent_not_sampled\x18\x04\x20\x01(\x0b2$.global\
    .TracingConfiguration.SamplerR\x16remoteParentNotSampled\x12X\n\x15remot\
    e_parent_sampled\x18\x05\x20\x01(\x0b2$.global.TracingConfiguration.Samp\
    lerR\x13remoteParentSampled\x1a{\n\x0bMaximumRate\x12*\n\x11samples_per_\
    epoch\x18\x01\x20\x01(\x03R\x0fsamplesPerEpoch\x12@\n\x0eepoch_duration\
    \x18\x02\x20\x01(\x0b2\x19.google.protobuf.DurationR\repochDurationB\x08\
    \n\x06policy\"-\n\x15SetUmaskConfiguration\x12\x14\n\x05umask\x18\x01\
    \x20\x01(\rR\x05umask\"\xe9\x03\n\rConfiguration\x126\n\x07tracing\x18\
    \x01\x20\x01(\x0b2\x1c.global.TracingConfigurationR\x07tracing\x124\n\
    \x16mutex_profile_fraction\x18\x02\x20\x01(\x05R\x14mutexProfileFraction\
    \x12a\n\x16prometheus_pushgateway\x18\x03\x20\x01(\x0b2*.global.Promethe\
    usPushgatewayConfigurationR\x15prometheusPushgateway\x12\x1b\n\tlog_path\
    s\x18\x05\x20\x03(\tR\x08logPaths\x12b\n\x17diagnostics_http_server\x18\
    \x06\x20\x01(\x0b2*.global.DiagnosticsHTTPServerConfigurationR\x15diagno\
    sticsHttpServer\x12:\n\tset_umask\x18\x07\x20\x01(\x0b2\x1d.global.SetUm\
    askConfigurationR\x08setUmask\x12D\n\x1fgrpc_forward_and_reuse_metadata\
    \x18\x08\x20\x03(\tR\x1bgrpcForwardAndReuseMetadataJ\x04\x08\x04\x10\x05\
    \"\xcb\x01\n\"DiagnosticsHTTPServerConfiguration\x12%\n\x0elisten_addres\
    s\x18\x01\x20\x01(\tR\rlistenAddress\x12!\n\x0cenable_pprof\x18\x02\x20\
    \x01(\x08R\x0benablePprof\x12+\n\x11enable_prometheus\x18\x03\x20\x01(\
    \x08R\x10enablePrometheus\x12.\n\x13enable_active_spans\x18\x04\x20\x01(\
    \x08R\x11enableActiveSpansb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
